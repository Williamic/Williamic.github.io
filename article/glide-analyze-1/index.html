<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="8szEBDhTLveYnlc_8VLUBz22yXDk5GKI7ujb0PVRVMQ" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Glide源码解析（一） - 王威拓 | Blog
        
    </title>

    <link rel="canonical" href="https://williamic.github.io/article/glide-analyze-1/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/header.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Android" title="Android">Android</a>
                            
                              <a class="tag" href="/tags/#Glide" title="Glide">Glide</a>
                            
                        </div>
                        <h1>Glide源码解析（一）</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Williamic on
                            2021-05-08
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">王威拓</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="一-前言">一、前言</h2>
<h3 id="1基本加载流程">1.基本加载流程</h3>
<p>   下面是Glide最简单的加载图片的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(Context)</span><br><span class="line">    .load(url)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure>
<p>   虽然只有简单一句话，但是按照官方的说法，背后有成吨的代码来实现。接下来会对这行代码进行具体的梳理，来看看Glide是如何加载一张图片的。</p>
<h2 id="二-加载流程解析">二、加载流程解析</h2>
<h3 id="1with-方法">1.with( )方法</h3>
<h4 id="1with">1）With</h4>
<p><img src="./glide-analyze-1_p1.png" alt="with的重载方法"><br>
   <code>with()</code>方法有6个重载，可以传入Activity、Fragment或者Context，虽然传入的参数不同，但都是获取上下文来调用<code>getRetriever()</code>方法返回一个<code>RequestManagerRetriever</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  private static RequestManagerRetriever getRetriever(@Nullable Context context) &#123;</span><br><span class="line">    // Context could be null for other reasons (ie the user passes in null), but in practice it will</span><br><span class="line">    // only occur due to errors with the Fragment lifecycle.</span><br><span class="line">    Preconditions.checkNotNull(</span><br><span class="line">        context,</span><br><span class="line">        &quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot;</span><br><span class="line">            + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;</span><br><span class="line">            + &quot;is attached or after the Fragment is destroyed).&quot;);</span><br><span class="line">    return Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   先对Context进行非空检查，然后在getRetriever方法中调用get方法构建一个Glide单例，使用双重检查锁确保Glide只进行一次初始化。get方法最终会调用<code>initializeGlide(Context context, GlideBuilder builder, GeneratedAppGlideModule annotationGeneratedModule)</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Get the singleton.</span><br><span class="line">   *</span><br><span class="line">   * @return the singleton</span><br><span class="line">   */</span><br><span class="line">  @NonNull</span><br><span class="line">  // Double checked locking is safe here.</span><br><span class="line">  @SuppressWarnings(&quot;GuardedBy&quot;)</span><br><span class="line">  public static Glide get(@NonNull Context context) &#123;</span><br><span class="line">    if (glide == null) &#123;</span><br><span class="line">      GeneratedAppGlideModule annotationGeneratedModule =</span><br><span class="line">          getAnnotationGeneratedGlideModules(context.getApplicationContext());</span><br><span class="line">      synchronized (Glide.class) &#123;</span><br><span class="line">        if (glide == null) &#123;</span><br><span class="line">          checkAndInitializeGlide(context, annotationGeneratedModule);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return glide;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2glidemodule">2）GlideModule</h4>
<p>   上面的GeneratedAppGlideModule对象是由<code>getAnnotationGeneratedGlideModules(con-text.getApplicationContext())</code>方法获取Glide注解生成的GlideModule。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules(Context context) &#123;</span><br><span class="line">    GeneratedAppGlideModule result = null;</span><br><span class="line">    ...</span><br><span class="line">    Class&lt;GeneratedAppGlideModule&gt; clazz =</span><br><span class="line">        (Class&lt;GeneratedAppGlideModule&gt;)</span><br><span class="line">            Class.forName(&quot;com.bumptech.glide.GeneratedAppGlideModuleImpl&quot;);</span><br><span class="line">    result = clazz.getDeclaredConstructor(Context.class)</span><br><span class="line">                .newInstance(context.getApplicationContext());</span><br><span class="line">    ...</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   这是在Glide 4.x中提供的配置模式，使用@GlideModule注解进行标记，而在Glide 3.x中，是需要在AndroidManifest.xml中指定一个继承自GlideModule的自定义类。获取到的<code>GeneratedAppGli-deModule</code>对象会作为参数传递到<code>initializeGlide()</code>方法中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static void initializeGlide(</span><br><span class="line">      @NonNull Context context,</span><br><span class="line">      @NonNull GlideBuilder builder,</span><br><span class="line">      @Nullable GeneratedAppGlideModule annotationGeneratedModule) &#123;</span><br><span class="line">    Context applicationContext = context.getApplicationContext();</span><br><span class="line">    List&lt;com.bumptech.glide.module.GlideModule&gt; manifestModules = Collections.emptyList();</span><br><span class="line">    </span><br><span class="line">    //如果注解生成的Module为空或者可配置的mainfest标志为true，</span><br><span class="line">    //则获取manifest里面的GlideModule模块</span><br><span class="line">    </span><br><span class="line">    if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) &#123;</span><br><span class="line">      manifestModules = new ManifestParser(applicationContext).parse();</span><br><span class="line">    &#125;</span><br><span class="line">    //如果注解生成的Module和通过反射annotationGeneratedModule拿到的Module都不为空，</span><br><span class="line">    //那就过滤Manifest中的Module</span><br><span class="line">    if (annotationGeneratedModule != null</span><br><span class="line">        &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123;</span><br><span class="line">        ······</span><br><span class="line">    &#125;</span><br><span class="line">    ······</span><br><span class="line">    //初始化RequestManager并赋值给GlideBuilder</span><br><span class="line">    RequestManagerRetriever.RequestManagerFactory factory =</span><br><span class="line">        annotationGeneratedModule != null</span><br><span class="line">            ? annotationGeneratedModule.getRequestManagerFactory()</span><br><span class="line">            : null;</span><br><span class="line">    builder.setRequestManagerFactory(factory);</span><br><span class="line">    ······</span><br><span class="line">    //初始化各种配置</span><br><span class="line">    Glide glide = builder.build(applicationContext);</span><br><span class="line">    //注册Application生命周期监听</span><br><span class="line">    applicationContext.registerComponentCallbacks(glide);</span><br><span class="line">    Glide.glide = glide;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3build">3）Build</h4>
<p>   <code>GlideBuilder.build()</code>方法创建了各种线程池和缓存池。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  Glide build(@NonNull Context context) &#123;</span><br><span class="line">    //创建请求图片线程池</span><br><span class="line">    if (sourceExecutor == null) &#123;</span><br><span class="line">      sourceExecutor = GlideExecutor.newSourceExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    //创建硬盘缓存线程池</span><br><span class="line">    if (diskCacheExecutor == null) &#123;</span><br><span class="line">      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    //创建动画线程池</span><br><span class="line">    if (animationExecutor == null) &#123;</span><br><span class="line">      animationExecutor = GlideExecutor.newAnimationExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    //计算需要设置的缓存大小</span><br><span class="line">    if (memorySizeCalculator == null) &#123;</span><br><span class="line">      memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (connectivityMonitorFactory == null) &#123;</span><br><span class="line">      connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (bitmapPool == null) &#123;</span><br><span class="line">      //根据设备的屏幕密度和尺寸，获取当前设备推荐的bitmap池大小</span><br><span class="line">      int size = memorySizeCalculator.getBitmapPoolSize();</span><br><span class="line">      if (size &gt; 0) &#123;</span><br><span class="line">        //创建图片线程池缓存Lru</span><br><span class="line">        bitmapPool = new LruBitmapPool(size);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        bitmapPool = new BitmapPoolAdapter();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建对象数组池缓存</span><br><span class="line">    if (arrayPool == null) &#123;</span><br><span class="line">      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建内存缓存</span><br><span class="line">    if (memoryCache == null) &#123;</span><br><span class="line">      memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (diskCacheFactory == null) &#123;</span><br><span class="line">      diskCacheFactory = new InternalCacheDiskCacheFactory(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (engine == null) &#123;</span><br><span class="line">      engine =</span><br><span class="line">          new Engine(</span><br><span class="line">              memoryCache,</span><br><span class="line">              diskCacheFactory,</span><br><span class="line">              diskCacheExecutor,</span><br><span class="line">              sourceExecutor,</span><br><span class="line">              GlideExecutor.newUnlimitedSourceExecutor(),</span><br><span class="line">              animationExecutor,</span><br><span class="line">              isActiveResourceRetentionAllowed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (defaultRequestListeners == null) &#123;</span><br><span class="line">      defaultRequestListeners = Collections.emptyList();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GlideExperiments experiments = glideExperimentsBuilder.build();</span><br><span class="line">    RequestManagerRetriever requestManagerRetriever =</span><br><span class="line">        new RequestManagerRetriever(requestManagerFactory, experiments);</span><br><span class="line"></span><br><span class="line">    return new Glide(</span><br><span class="line">        context,</span><br><span class="line">        engine,</span><br><span class="line">        memoryCache,</span><br><span class="line">        bitmapPool,</span><br><span class="line">        arrayPool,</span><br><span class="line">        requestManagerRetriever,</span><br><span class="line">        connectivityMonitorFactory,</span><br><span class="line">        logLevel,</span><br><span class="line">        defaultRequestOptionsFactory,</span><br><span class="line">        defaultTransitionOptions,</span><br><span class="line">        defaultRequestListeners,</span><br><span class="line">        experiments);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4requestmanagerretrieverget">4）RequestManagerRetriever#get</h4>
<p>   在RequestManagerRetriever的get方法中，对不同的Context对象做了不同的处理。主要分为Application类型的Context和非Application类型的Context。非Application类型中再分为Activity、Fragment、View等类型，对应各自的重载方法。如果Context是Application，或者当前线程是子线程，则会调用getApplicationManager(context)方法，使得Glide请求的生命周期与ApplicationContext的生命周期关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  public RequestManager get(@NonNull Context context) &#123;</span><br><span class="line">    if (context == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</span><br><span class="line">    &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</span><br><span class="line">        //当前线程是主线程，并且context不是Application</span><br><span class="line">      if (context instanceof FragmentActivity) &#123;</span><br><span class="line">        return get((FragmentActivity) context);</span><br><span class="line">      &#125; else if (context instanceof Activity) &#123;</span><br><span class="line">        return get((Activity) context);</span><br><span class="line">      &#125; else if (context instanceof ContextWrapper</span><br><span class="line">          // Only unwrap a ContextWrapper if the baseContext has a non-null application context.</span><br><span class="line">          // Context#createPackageContext may return a Context without an Application instance,</span><br><span class="line">          // in which case a ContextWrapper may be used to attach one.</span><br><span class="line">          &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) &#123;</span><br><span class="line">        return get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //context是Application，则将请求与ApplicationLifecycle关联</span><br><span class="line">    //生命周期跟随Application</span><br><span class="line">    return getApplicationManager(context);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   当传入的Context是Fragment或者FargmentActivity时，会调用get的重载方法，执行<code>supportFragmentGet()</code>方法，在当前页面添加一个<code>SupportRequestManagerFragment</code>；同理当传入的Context为Activity时候，执行<code>fragmentGet()</code>方法，在当前页面添加一个<code>RequestManager-Fragment</code>。当传入的Conetext类型是View时，判断View所在的内容是Activity还是Fragment，再分别调用对应的get()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">  @NonNull</span><br><span class="line">  public RequestManager get(@NonNull Activity activity) &#123;</span><br><span class="line">    //判断当前是否在子线程中请求任务</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      //通过 Application 级别的 Context 加载</span><br><span class="line">      return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //检查 Activity 是否已经销毁</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      //拿到当前 Activity 的 FragmentManager </span><br><span class="line">      android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">      //主要是生成一个 Fragment 然后绑定一个请求管理 RequestManager</span><br><span class="line">      return fragmentGet(</span><br><span class="line">          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   下面的代码示例以<code>getSupportRequestManagerFragment</code>为例子，这里需要注意的是，下面的两处current判空处理，实际上确保在一个Activity中只添加一个<code>SupportRequestManager-Fragment</code>，其中的<code>pendingSupportRequestManagerFragments</code>是一个HashMap，用于临时保存<code>SupportRequestManagerFragment</code>的映射关系。因为<code>commitAllowingStateLosss()</code>方法只是将事物添加到消息队列中，这是一个异步处理方法，最终还需要Handler执行消息将其真正添加到FragmentManager中，如果此时又执行了get()方法创建<code>SupportRequestManagerFragment</code>，可能会导致创建多个，所以通过<code>pendingSupportRequestManagerFragments</code>来添加临时映射以避免这种情况产生。最后发送的<code>ID_REMOVE_SUPPORT_FRAGMENT_MANAGER</code>消息，实际上就是移除<code>pendingSupportRequest-ManagerFragments</code>中的映射关系，根据Handler的消息机制，当<code>ID_REMOVE_SUPPORT_FRAGMEN-T_MANAGER</code>消息执行完成时，<code>SupportRequestManagerFragment</code>也已经添加成功了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  private SupportRequestManagerFragment getSupportRequestManagerFragment(</span><br><span class="line">      @NonNull final FragmentManager fm, @Nullable Fragment parentHint) &#123;</span><br><span class="line">      //尝试获取TAG为FRAGMENT_TAG的SupportRequestManagerFragment</span><br><span class="line">    SupportRequestManagerFragment current =</span><br><span class="line">        (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    if (current == null) &#123;</span><br><span class="line">      //如果current为空，则从pendingSupportRequestManagerFragments中尝试获取一个临时的</span><br><span class="line">      //SupportRequestManagerFragment对象</span><br><span class="line">      current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">      if (current == null) &#123;</span><br><span class="line">          //若current为空，则实例化一个SupportRequestManagerFragment，并临时添加</span><br><span class="line">          //映射关系在pendingSupportRequestManagerFragments中</span><br><span class="line">        current = new SupportRequestManagerFragment();</span><br><span class="line">        current.setParentFragmentHint(parentHint);</span><br><span class="line">        pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">        //添加到handler队列</span><br><span class="line">        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">        //发送一个handler消息，此消息执行后会remove掉pendingSupportRequestManagerFragments中</span><br><span class="line">        //SupportRequestManagerFragment的临时映射关系，意味着此时SupportRequestManagerFragment已成功创建</span><br><span class="line">        handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return current;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   这里的<code>SupportRequestManagerFragment</code>和<code>RequestManagerFragment</code>都是无界Fragment。因为Fragment生命周期跟随Activity，当Activity销毁时，Fragment也会跟着销毁。这里利用添加Fragment的方法与RequestManager绑定在一起，用于监听生命周期。</p>
<h4 id="5requestmanagerfragment">5）RequestManagerFragment</h4>
<p>   在RequestManagerFragment持有一个lifecycle，在Fragment进入相应的生命周期的时候，会通知lifecycle执行相关方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class RequestManagerFragment extends Fragment &#123;</span><br><span class="line">  ...</span><br><span class="line">  private final ActivityFragmentLifecycle lifecycle;</span><br><span class="line">  ...</span><br><span class="line">　@Override</span><br><span class="line">  public void onStart() &#123;</span><br><span class="line">    super.onStart();</span><br><span class="line">    lifecycle.onStart();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onStop() &#123;</span><br><span class="line">    super.onStop();</span><br><span class="line">    lifecycle.onStop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    lifecycle.onDestroy();</span><br><span class="line">  &#125;　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6with小结">6）with小结</h4>
<ul>
<li>Glide初始化各种配置信息（缓存、请求线程池等）</li>
<li>将glide请求与application、无界Fragment进行绑定，通过lifecycle来监听相关的生命周期。</li>
<li>无界Fragment在创建过程中通过HashMap添加临时映射关系和通过Handler消息机制，来确保一个Activity只持有一个无界Fragment。</li>
</ul>
<h3 id="2load-方法">2.load( )方法</h3>
<h4 id="1requestmanagerload">1）RequestManager#load</h4>
<p>   <code>load()</code>有多个重载方法，返回类型是RequestBuilder对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//RequestManager的load的重载方法</span><br><span class="line">  @NonNull</span><br><span class="line">  @CheckResult</span><br><span class="line">  @Override</span><br><span class="line">  public RequestBuilder&lt;Drawable&gt; load(@Nullable Bitmap bitmap) &#123;</span><br><span class="line">    return asDrawable().load(bitmap);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2requestmanagerasdrawable">2）RequestManager#asDrawable</h4>
<p>   在<code>asDrawable()</code>方法中，继续调用了<code>as(Drawable.class)</code>方法，在as方法中，调用了RequestBuilder的构造方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">@CheckResult</span><br><span class="line">public RequestBuilder&lt;Drawable&gt; asDrawable() &#123;</span><br><span class="line">  return as(Drawable.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">@CheckResult</span><br><span class="line">public &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; as(</span><br><span class="line">    @NonNull Class&lt;ResourceType&gt; resourceClass) &#123;</span><br><span class="line">  return new RequestBuilder&lt;&gt;(glide, this, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   但不管调用哪个重载方法，最终都会调用RequestBuilder的load方法，load方法会调用的<code>loadGeneric</code>方法，会将传入的对象看成object对象，并赋值给model对象，将<code>isModelSet</code>设置为true。这里还注意到一个<code>apply(@NonNull BaseRequestOptions&lt;?&gt; requestOptions)</code>方法，前面提到的GlideBuilder的构造方法中用到的RequestOptionsFactory对象参数就是由RequestOptions构造的，用于配制缓存、占位符等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  @NonNull</span><br><span class="line">  @CheckResult</span><br><span class="line">  @Override</span><br><span class="line">  public RequestBuilder&lt;TranscodeType&gt; load(@Nullable Bitmap bitmap) &#123;</span><br><span class="line">    return loadGeneric(bitmap).apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">@NonNull</span><br><span class="line">private RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) &#123;</span><br><span class="line">  if (isAutoCloneEnabled()) &#123;</span><br><span class="line">    return clone().loadGeneric(model);</span><br><span class="line">  &#125;</span><br><span class="line">  this.model = model;</span><br><span class="line">  isModelSet = true;</span><br><span class="line">  return selfOrThrowIfLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3load小结">3）load小结</h4>
<p>   可以发现到目前为止还没有真正的涉及加载的部分，load部分的代码只是将要加载的内容赋值给了model对象，接下来我们看看真正的加载部分into的解析。</p>
<h3 id="3into-方法">3.into( )方法</h3>
<h4 id="1requestbuilderinto">1）RequestBuilder#into</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  public ViewTarget&lt;ImageView, TranscodeType&gt; into(@NonNull ImageView view) &#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line"></span><br><span class="line">    BaseRequestOptions&lt;?&gt; requestOptions = this;</span><br><span class="line">    if (!requestOptions.isTransformationSet()</span><br><span class="line">        &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">        &amp;&amp; view.getScaleType() != null) &#123;</span><br><span class="line">      // Clone in this method so that if we use this RequestBuilder to load into a View and then</span><br><span class="line">      // into a different target, we don&apos;t retain the transformation applied based on the previous</span><br><span class="line">      // View&apos;s scale type.</span><br><span class="line">      //如果在 xml ImageView 节点中没有设置scaleType,那么默认在构造函数中进行了初始化为ScaleType.FIT_CENTER </span><br><span class="line">      switch (view.getScaleType()) &#123;</span><br><span class="line">        case CENTER_CROP:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">          break;</span><br><span class="line">        case CENTER_INSIDE:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          break;</span><br><span class="line">        case FIT_CENTER:</span><br><span class="line">        case FIT_START:</span><br><span class="line">        case FIT_END:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">          break;</span><br><span class="line">        case FIT_XY:</span><br><span class="line">          requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">          break;</span><br><span class="line">        case CENTER:</span><br><span class="line">        case MATRIX:</span><br><span class="line">        default:</span><br><span class="line">          // Do nothing.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return into(</span><br><span class="line">        glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">        /*targetListener=*/ null,</span><br><span class="line">        requestOptions,</span><br><span class="line">        Executors.mainThreadExecutor());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>RequestBuilder</code>的into方法先获取了传递进来的ImageView的ScaleType，Glide会在requestOptions中实现自己的Scale使得最后呈现的图片与ImageView的scaleType保持一致。接下来调用<code>into</code>重载继续构建，所以我们看一下<code>buildImageViewTarget</code>方法。</p>
<h4 id="2buildimageviewtarget">2）buildImageViewTarget</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  public &lt;X&gt; ViewTarget&lt;ImageView, X&gt; buildImageViewTarget(</span><br><span class="line">      @NonNull ImageView imageView, @NonNull Class&lt;X&gt; transcodeClass) &#123;</span><br><span class="line">    return imageViewTargetFactory.buildTarget(imageView, transcodeClass);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">@NonNull</span><br><span class="line">public &lt;Z&gt; ViewTarget&lt;ImageView, Z&gt; buildTarget(</span><br><span class="line">    @NonNull ImageView view, @NonNull Class&lt;Z&gt; clazz) &#123;</span><br><span class="line">  if (Bitmap.class.equals(clazz)) &#123;</span><br><span class="line">    return (ViewTarget&lt;ImageView, Z&gt;) new BitmapImageViewTarget(view);</span><br><span class="line">  &#125; else if (Drawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">    return (ViewTarget&lt;ImageView, Z&gt;) new DrawableImageViewTarget(view);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new IllegalArgumentException(</span><br><span class="line">        &quot;Unhandled class: &quot; + clazz + &quot;, try .as*(Class).transcode(ResourceTranscoder)&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   buildTarget方法返回了两种类型的ViewTarget，一种是<code>BitmapImageViewTarget</code>，一种是<code>DrawableImageViewTarget</code>，可以看到buildTarget方法的clazz参数只能是Bitmap或Drawable，否则会抛出异常。</p>
<h4 id="3drawableimageviewtarget">3）DrawableImageViewTarget</h4>
<p>   由于之前RequestBuilder中as方法传入的是Drawable.class，所以我们先关注DrawableImageViewTarget对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DrawableImageViewTarget extends ImageViewTarget&lt;Drawable&gt; &#123;</span><br><span class="line"></span><br><span class="line">  public DrawableImageViewTarget(ImageView view) &#123;</span><br><span class="line">    super(view);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&#123;&quot;unused&quot;, &quot;deprecation&quot;&#125;)</span><br><span class="line">  @Deprecated</span><br><span class="line">  public DrawableImageViewTarget(ImageView view, boolean waitForLayout) &#123;</span><br><span class="line">    super(view, waitForLayout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void setResource(@Nullable Drawable resource) &#123;</span><br><span class="line">    view.setImageDrawable(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   从上面代码可以知道<code>DrawableImageViewTarget</code>继承的是<code>ImageViewTarget</code>重写的<code>setResource</code>函数，实现了显示Drawable图片的方法。下面我们重新回到into方法上去。</p>
<h4 id="4requestbuilderinto">4）RequestBuilder#into</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(</span><br><span class="line">      @NonNull Y target,</span><br><span class="line">      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="line">      BaseRequestOptions&lt;?&gt; options,</span><br><span class="line">      Executor callbackExecutor) &#123;</span><br><span class="line">    Preconditions.checkNotNull(target);</span><br><span class="line">    if (!isModelSet) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;You must call #load() before calling #into()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生成一个Glide request请求</span><br><span class="line">    Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line"></span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line">    if (request.isEquivalentTo(previous)</span><br><span class="line">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">      // If the request is completed, beginning again will ensure the result is re-delivered,</span><br><span class="line">      // triggering RequestListeners and Targets. If the request is failed, beginning again will</span><br><span class="line">      // restart the request, giving it another chance to complete. If the request is already</span><br><span class="line">      // running, we can let it continue running without interruption.</span><br><span class="line">      if (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">        // Use the previous request rather than the new one to allow for optimizations like skipping</span><br><span class="line">        // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span><br><span class="line">        // that are done in the individual Request.</span><br><span class="line">        previous.begin();</span><br><span class="line">      &#125;</span><br><span class="line">      return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清理掉目标请求管理</span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    //重新为目标设置一request请求</span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    //将构建出来的request交给RequestManager的track方法来执行</span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   上面的代码首先通过buildRequest方法，构建出request请求，然后将request请求交给RequestManager的track方法来执行。接下来我们看一下buildRequest是如何构造request请求的。</p>
<h4 id="5requestbuilderbuildrequest">5）RequestBuilder#buildRequest</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Request buildRequest(</span><br><span class="line">      Target&lt;TranscodeType&gt; target,</span><br><span class="line">      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="line">      BaseRequestOptions&lt;?&gt; requestOptions,</span><br><span class="line">      Executor callbackExecutor) &#123;</span><br><span class="line">    return buildRequestRecursive(</span><br><span class="line">        /*requestLock=*/ new Object(),</span><br><span class="line">        target,</span><br><span class="line">        targetListener,</span><br><span class="line">        /*parentCoordinator=*/ null,</span><br><span class="line">        transitionOptions,</span><br><span class="line">        requestOptions.getPriority(),</span><br><span class="line">        requestOptions.getOverrideWidth(),</span><br><span class="line">        requestOptions.getOverrideHeight(),</span><br><span class="line">        requestOptions,</span><br><span class="line">        callbackExecutor);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   在<code>buildRequest</code>方法中，可以看到<code>buildRequest</code>调用了<code>buildRequestRecursive</code>方法，<code>buildRequestRecursive</code>中大部分代码都在处理缩略图，但这不是最终调用的地方，然后继续跟随下去发现<code>buildRequestRecursive</code>又调用了<code>obtainRequest</code>方法，<code>obtainRequest</code>中传入了上一步提到的target对象，以及图片尺寸的<code>overrideWidth</code>、<code>overrideHeight</code>，和<code>RequestOptions</code>参数。<code>obtainRequest</code>最终都会把参数传递到<code>SingleRequest.obtain</code>中去，所以最终是<code>SingleRequest</code>类来构建请求。<br>
   同时我们可以看到，在<code>SingleRequest</code>中实现了<code>Request</code>接口，实现了<code>begin</code>、<code>clear</code>、<code>pause</code>等方法，这里我们先暂时放一下，后续再来看这个<code>Request</code>接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface Request &#123;</span><br><span class="line"></span><br><span class="line">  void begin();</span><br><span class="line"></span><br><span class="line">  void clear();</span><br><span class="line"></span><br><span class="line">  void pause();</span><br><span class="line">  </span><br><span class="line">  boolean isRunning();</span><br><span class="line"></span><br><span class="line">  boolean isComplete();</span><br><span class="line"></span><br><span class="line">  boolean isCleared();</span><br><span class="line"></span><br><span class="line">  boolean isAnyResourceSet();</span><br><span class="line"></span><br><span class="line">  boolean isEquivalentTo(Request other);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6requestbuildertrack">6）RequestBuilder#track</h4>
<p>   下面我们来看<code>track</code>函数的执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//这里对当前 class 加了一个同步锁避免线程引起的安全性  </span><br><span class="line">synchronized void track(@NonNull Target&lt;?&gt; target, @NonNull Request request) &#123;</span><br><span class="line">    //添加一个任务 </span><br><span class="line">    targetTracker.track(target);</span><br><span class="line">    //执行 Glide request</span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void runRequest(@NonNull Request request) &#123;</span><br><span class="line">    //添加一个请求</span><br><span class="line">    requests.add(request);</span><br><span class="line">    //是否暂停</span><br><span class="line">    if (!isPaused) &#123;</span><br><span class="line">      //没有暂停，开始调用 Request begin 执行</span><br><span class="line">      request.begin();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //如果调用了 暂停，清理请求</span><br><span class="line">      request.clear();</span><br><span class="line">      pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>track</code>方法中执行了RequestTracker类的<code>runRequest</code>方法，用于判断当前Glide是否在暂停状态，不是暂停状态则执行Request的<code>begin</code>方法，否则将这个<code>Request</code>加入到等待队列<code>pendingRequests</code>中，目的是确保不会在开始运行之前或者暂停的时候被垃圾回收。这里的<code>begin</code>方法是前面提到过的<code>Request</code>接口中的方法，其实现类在<code>SingleRequest</code>中，所以接下来我们来看一下<code>SingleRequest</code>中的<code>begin</code>方法。</p>
<h4 id="7singlerequestbegin">7）SingleRequest#begin</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void begin() &#123;</span><br><span class="line">    synchronized (requestLock) &#123;</span><br><span class="line">      assertNotCallingCallbacks();</span><br><span class="line">      stateVerifier.throwIfRecycled();</span><br><span class="line">      startTime = LogTime.getLogTime();</span><br><span class="line">      //model（url）为空</span><br><span class="line">      if (model == null) &#123;</span><br><span class="line">        //检查外部调用的尺寸是否有效</span><br><span class="line">        if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">          width = overrideWidth;</span><br><span class="line">          height = overrideHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        //失败的回调</span><br><span class="line">        int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;</span><br><span class="line">        onLoadFailed(new GlideException(&quot;Received null model&quot;), logLevel);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (status == Status.RUNNING) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot restart a running request&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      if (status == Status.COMPLETE) &#123;</span><br><span class="line">        //从缓存中找到则直接返回</span><br><span class="line">        onResourceReady(</span><br><span class="line">            resource, DataSource.MEMORY_CACHE, /* isLoadedFromAlternateCacheKey= */ false);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Restarts for requests that are neither complete nor running can be treated as new requests</span><br><span class="line">      // and can run again from the beginning.</span><br><span class="line"></span><br><span class="line">      cookie = GlideTrace.beginSectionAsync(TAG);</span><br><span class="line">      status = Status.WAITING_FOR_SIZE;</span><br><span class="line">      if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        //当宽高固定时直接执行onSizeReady，这也是核心方法</span><br><span class="line">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        //如果宽高没有固定，则通过getSize加载图片的大小尺寸</span><br><span class="line">        //最终还是会调用onSizeReady方法</span><br><span class="line">        target.getSize(this);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">          &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">          // 预先加载设置的缩略图</span><br><span class="line">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">      &#125;</span><br><span class="line">      if (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">        logV(&quot;finished run method in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   从<code>requestManager.track(target,request)</code>开始，最终会执行到<code>SingleRequest#begin</code>()方法的<code>onSizeReady</code>，接下来我们直接看<code>onSizeReady</code>方法。</p>
<h4 id="8singlerequestonsizeready">8）SingleRequest#onSizeReady</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void onSizeReady(int width, int height) &#123;</span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    synchronized (requestLock) &#123;</span><br><span class="line">      if (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">        logV(&quot;Got onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">      &#125;</span><br><span class="line">      if (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">      float sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class="line">      this.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class="line">      this.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class="line"></span><br><span class="line">      if (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">        logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">      &#125;</span><br><span class="line">      // 根据给定的配置，加载各种对象</span><br><span class="line">      loadStatus =</span><br><span class="line">          engine.load(</span><br><span class="line">              glideContext,</span><br><span class="line">              model,</span><br><span class="line">              requestOptions.getSignature(),</span><br><span class="line">              this.width,</span><br><span class="line">              this.height,</span><br><span class="line">              requestOptions.getResourceClass(),</span><br><span class="line">              transcodeClass,</span><br><span class="line">              priority,</span><br><span class="line">              requestOptions.getDiskCacheStrategy(),</span><br><span class="line">              requestOptions.getTransformations(),</span><br><span class="line">              requestOptions.isTransformationRequired(),</span><br><span class="line">              requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">              requestOptions.getOptions(),</span><br><span class="line">              requestOptions.isMemoryCacheable(),</span><br><span class="line">              requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">              requestOptions.getUseAnimationPool(),</span><br><span class="line">              requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">              this,</span><br><span class="line">              callbackExecutor);</span><br><span class="line">      if (status != Status.RUNNING) &#123;</span><br><span class="line">        loadStatus = null;</span><br><span class="line">      &#125;</span><br><span class="line">      if (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">        logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   到了这一步，主要调用了<code>engine.load()</code>方法并返回加载状态。engine主要负责加载、管理活动缓存和内存缓存资源的类。</p>
<h4 id="9engineload">9）Engine#load</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public &lt;R&gt; LoadStatus load(</span><br><span class="line">      GlideContext glideContext,</span><br><span class="line">      Object model,</span><br><span class="line">      Key signature,</span><br><span class="line">      int width,</span><br><span class="line">      int height,</span><br><span class="line">      Class&lt;?&gt; resourceClass,</span><br><span class="line">      Class&lt;R&gt; transcodeClass,</span><br><span class="line">      Priority priority,</span><br><span class="line">      DiskCacheStrategy diskCacheStrategy,</span><br><span class="line">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="line">      boolean isTransformationRequired,</span><br><span class="line">      boolean isScaleOnlyOrNoTransform,</span><br><span class="line">      Options options,</span><br><span class="line">      boolean isMemoryCacheable,</span><br><span class="line">      boolean useUnlimitedSourceExecutorPool,</span><br><span class="line">      boolean useAnimationPool,</span><br><span class="line">      boolean onlyRetrieveFromCache,</span><br><span class="line">      ResourceCallback cb,</span><br><span class="line">      Executor callbackExecutor) &#123;</span><br><span class="line">    long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;</span><br><span class="line"></span><br><span class="line">    //拿到缓存或者请求的 key</span><br><span class="line">    EngineKey key =</span><br><span class="line">        keyFactory.buildKey(</span><br><span class="line">            model,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            transformations,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            options);</span><br><span class="line"></span><br><span class="line">    //这里用上面计算后的key来获取内存缓存</span><br><span class="line">    EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line"></span><br><span class="line">        //如果内存缓存不存在</span><br><span class="line">      if (memoryResource == null) &#123;</span><br><span class="line">        return waitForExistingOrStartNewJob(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            .....</span><br><span class="line">            //传入的各种参数</span><br><span class="line">            .....</span><br><span class="line">            startTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Avoid calling back while holding the engine lock, doing so makes it easier for callers to</span><br><span class="line">    // deadlock.</span><br><span class="line">    cb.onResourceReady(</span><br><span class="line">        memoryResource, DataSource.MEMORY_CACHE, /* isLoadedFromAlternateCacheKey= */ false);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>load</code>中先根据各种参数来构建key，再接着调用<code>loadFromMemory</code>方法来获取内存缓存，代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">  private EngineResource&lt;?&gt; loadFromMemory(</span><br><span class="line">      EngineKey key, boolean isMemoryCacheable, long startTime) &#123;</span><br><span class="line">    if (!isMemoryCacheable) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key);</span><br><span class="line">    //根据 key 拿到活动缓存中的资源</span><br><span class="line">    if (active != null) &#123;</span><br><span class="line">      if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      return active;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //尝试从 LruResourceCache 中找寻这个资源 </span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key);</span><br><span class="line">    if (cached != null) &#123;</span><br><span class="line">      if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      return cached;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   如果<code>isMemoryCacheable</code>参数为false，则返回为空，这个参数就是<code>BaseRequestOptions</code>中加载图片的时候设置的是否开启缓存来决定的，然后尝试获取<code>ActiveResources</code>（活动缓存，内部是一个弱引用Map）和<code>LruResourceCache</code>（Lru内存缓存）中寻找资源，如果有则对应监听的<code>onResourceReady</code>表示数据准备好了，如果都没有找到则返回为空。当返回为空时，则会进入<code>waitForExistingOrStartNewJob</code>方法。</p>
<h4 id="10enginewaitforexistingorstartnewjob">10）Engine#waitForExistingOrStartNewJob</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private &lt;R&gt; LoadStatus waitForExistingOrStartNewJob(</span><br><span class="line">      GlideContext glideContext,</span><br><span class="line">      Object model,</span><br><span class="line">      Key signature,</span><br><span class="line">      int width,</span><br><span class="line">      int height,</span><br><span class="line">      Class&lt;?&gt; resourceClass,</span><br><span class="line">      Class&lt;R&gt; transcodeClass,</span><br><span class="line">      Priority priority,</span><br><span class="line">      DiskCacheStrategy diskCacheStrategy,</span><br><span class="line">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="line">      boolean isTransformationRequired,</span><br><span class="line">      boolean isScaleOnlyOrNoTransform,</span><br><span class="line">      Options options,</span><br><span class="line">      boolean isMemoryCacheable,</span><br><span class="line">      boolean useUnlimitedSourceExecutorPool,</span><br><span class="line">      boolean useAnimationPool,</span><br><span class="line">      boolean onlyRetrieveFromCache,</span><br><span class="line">      ResourceCallback cb,</span><br><span class="line">      Executor callbackExecutor,</span><br><span class="line">      EngineKey key,</span><br><span class="line">      long startTime) &#123;</span><br><span class="line">      </span><br><span class="line">    //根据 Key 看看缓存中是否正在执行</span><br><span class="line">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    if (current != null) &#123;</span><br><span class="line">      //如果正在执行，把数据回调出去</span><br><span class="line">      current.addCallback(cb, callbackExecutor);</span><br><span class="line">      if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      return new LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //否则则构建新的请求任务</span><br><span class="line">    EngineJob&lt;R&gt; engineJob =</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">            key,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">        decodeJobFactory.build(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            key,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            diskCacheStrategy,</span><br><span class="line">            transformations,</span><br><span class="line">            isTransformationRequired,</span><br><span class="line">            isScaleOnlyOrNoTransform,</span><br><span class="line">            onlyRetrieveFromCache,</span><br><span class="line">            options,</span><br><span class="line">            engineJob);</span><br><span class="line">    </span><br><span class="line">    //把当前需要执行的 key 添加进缓存</span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line">    //执行任务的回调</span><br><span class="line">    engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">    //开始执行</span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">    return new LoadStatus(cb, engineJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   首先从执行缓存<code>jobs</code>中查找对应<code>key</code>的任务，如果找到了就说明已经在执行了，就不用重复了。如果没有找到，就会通过<code>engineJob.start</code>开启一个新的请求任务。下面我们看一下<code>engineJob.start</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start(DecodeJob&lt;R&gt; decodeJob) &#123;</span><br><span class="line">    this.decodeJob = decodeJob;</span><br><span class="line">    // Glide执行的线程池</span><br><span class="line">    GlideExecutor executor =</span><br><span class="line">        decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class="line">    executor.execute(decodeJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   通过观察<code>DecodeJob</code>类知道，其实现了<code>Runnable</code>接口。<code>GlideExecutor</code>线程池开始执行就会调用run函数，所以我们跟踪<code>DecodeJob#run</code>方法。</p>
<h4 id="11decodejobrun">11）DecodeJob#run</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class DecodeJob&lt;R&gt;</span><br><span class="line">    implements DataFetcherGenerator.FetcherReadyCallback,</span><br><span class="line">        Runnable,</span><br><span class="line">        Comparable&lt;DecodeJob&lt;?&gt;&gt;,</span><br><span class="line">        Poolable &#123;</span><br><span class="line">        @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">            GlideTrace.beginSectionFormat(&quot;DecodeJob#run(reason=%s, model=%s)&quot;, runReason, model);</span><br><span class="line">            DataFetcher&lt;?&gt; localFetcher = currentFetcher;</span><br><span class="line">            try &#123;</span><br><span class="line">              //根据参数是否取消当前请求</span><br><span class="line">              if (isCancelled) &#123;</span><br><span class="line">                notifyFailed();</span><br><span class="line">                return;</span><br><span class="line">              &#125;</span><br><span class="line">              //执行的方法</span><br><span class="line">              runWrapped();</span><br><span class="line">            &#125; catch (CallbackException e) &#123;</span><br><span class="line">              .....</span><br><span class="line">              //错误回调</span><br><span class="line">              throw e;</span><br><span class="line">              .....</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>run</code>方法最终会调用<code>runWrapped</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private void runWrapped() &#123;</span><br><span class="line">    switch (runReason) &#123;</span><br><span class="line">      case INITIALIZE:</span><br><span class="line">        stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">        currentGenerator = getNextGenerator();</span><br><span class="line">        runGenerators();</span><br><span class="line">        break;</span><br><span class="line">      case SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">        runGenerators();</span><br><span class="line">        break;</span><br><span class="line">      case DECODE_DATA:</span><br><span class="line">        decodeFromRetrievedData();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new IllegalStateException(&quot;Unrecognized run reason: &quot; + runReason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  private Stage getNextStage(Stage current) &#123;</span><br><span class="line">      switch (current) &#123;</span><br><span class="line">         //如果外部调用配置了资源缓存策略，那么返回 Stage.RESOURCE_CACHE</span><br><span class="line">         //否则继续调用getNextStage(Stage.RESOURCE_CACHE)</span><br><span class="line">        case INITIALIZE:</span><br><span class="line">          return diskCacheStrategy.decodeCachedResource()</span><br><span class="line">              ? Stage.RESOURCE_CACHE</span><br><span class="line">              : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">        case RESOURCE_CACHE:</span><br><span class="line">         //如果外部配置了源数据缓存，那么返回 Stage.DATA_CACHE</span><br><span class="line">         //否则继续调用getNextStage(Stage.DATA_CACHE)</span><br><span class="line">          return diskCacheStrategy.decodeCachedData()</span><br><span class="line">              ? Stage.DATA_CACHE</span><br><span class="line">              : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">        case DATA_CACHE:</span><br><span class="line">          //如果只能从缓存中获取数据，则直接返回 FINISHED，否则，返回Stage.SOURCE。</span><br><span class="line">          return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">        case SOURCE:</span><br><span class="line">        case FINISHED:</span><br><span class="line">          return Stage.FINISHED;</span><br><span class="line">        default:</span><br><span class="line">          throw new IllegalArgumentException(&quot;Unrecognized stage: &quot; + current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    private DataFetcherGenerator getNextGenerator() &#123;</span><br><span class="line">        switch (stage) &#123;</span><br><span class="line">          case RESOURCE_CACHE:</span><br><span class="line">            return new ResourceCacheGenerator(decodeHelper, this);</span><br><span class="line">          case DATA_CACHE:</span><br><span class="line">            return new DataCacheGenerator(decodeHelper, this);</span><br><span class="line">          case SOURCE:</span><br><span class="line">            return new SourceGenerator(decodeHelper, this);</span><br><span class="line">          case FINISHED:</span><br><span class="line">            return null;</span><br><span class="line">          default:</span><br><span class="line">            throw new IllegalStateException(&quot;Unrecognized stage: &quot; + stage);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>runWrapped</code>方法会判断<code>runReason</code>类型，这里由于我们没有在外部配置缓存策略，所以<code>getNextStage</code>方法最终返回的是<code>Stage.SOURCE</code>状态。因此会调用<code>SourceGenerator</code>，返回源数据执行器。接下来我们看<code>runGenerators()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void runGenerators() &#123;</span><br><span class="line">    currentThread = Thread.currentThread();</span><br><span class="line">    startFetchTime = LogTime.getLogTime();</span><br><span class="line">    boolean isStarted = false;</span><br><span class="line">    //判断是否取消，是否开始</span><br><span class="line">    //调用 currentGenerator.startNext() 判断是否是属于开始执行的任务</span><br><span class="line">    while (!isCancelled</span><br><span class="line">        &amp;&amp; currentGenerator != null</span><br><span class="line">        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class="line">      stage = getNextStage(stage);</span><br><span class="line">      currentGenerator = getNextGenerator();</span><br><span class="line"></span><br><span class="line">      if (stage == Stage.SOURCE) &#123;</span><br><span class="line">        reschedule();</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   在该方法的<code>while</code>循环判断条件执行了<code>currentGenerator.startNext()</code>方法，所以我们接下来看<code>SourceGenerator</code>。</p>
<h4 id="12sourcegeneratorstartnext">12）SourceGenerator#startNext</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public boolean startNext() &#123;</span><br><span class="line">    //省略缓存判断部分</span><br><span class="line">    ...</span><br><span class="line">    loadData = null;</span><br><span class="line">    boolean started = false;</span><br><span class="line">    while (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">      //获取一个 ModelLoad 加载器</span><br><span class="line">      loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">      if (loadData != null</span><br><span class="line">          &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">              || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">        started = true;</span><br><span class="line">        startNextLoad(loadData);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return started;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private void startNextLoad(final LoadData&lt;?&gt; toStart) &#123;</span><br><span class="line">      //使用加载器中的fetcher.loadData方法来，根据优先级加载图片数据</span><br><span class="line">      loadData.fetcher.loadData(</span><br><span class="line">          helper.getPriority(),</span><br><span class="line">          new DataCallback&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onDataReady(@Nullable Object data) &#123;</span><br><span class="line">              if (isCurrentRequest(toStart)) &#123;</span><br><span class="line">                onDataReadyInternal(toStart, data);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onLoadFailed(@NonNull Exception e) &#123;</span><br><span class="line">              if (isCurrentRequest(toStart)) &#123;</span><br><span class="line">                onLoadFailedInternal(toStart, e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="13decodehelpergetloaddata">13）DecodeHelper#getLoadData</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;LoadData&lt;?&gt;&gt; getLoadData() &#123;</span><br><span class="line">    if (!isLoadDataSet) &#123;</span><br><span class="line">      isLoadDataSet = true;</span><br><span class="line">      loadData.clear();</span><br><span class="line">      //从 Glide 注册的 Model 来获取加载器</span><br><span class="line">      List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model);</span><br><span class="line">      //noinspection ForLoopReplaceableByForEach to improve perf</span><br><span class="line">      for (int i = 0, size = modelLoaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">        //开始构建加载器</span><br><span class="line">        ModelLoader&lt;Object, ?&gt; modelLoader = modelLoaders.get(i);</span><br><span class="line">        LoadData&lt;?&gt; current = modelLoader.buildLoadData(model, width, height, options);</span><br><span class="line">        if (current != null) &#123;</span><br><span class="line">          loadData.add(current);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loadData;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   在<code>getLoadData()</code>方法中，因为load方法加载的是URL，所以这里的<code>ModelLoad</code>的实现类是一个<code>HttpGlideUrlLoader</code>。它是在Glide初始化的时候通过<code>Registry.append()</code>添加的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())</span><br></pre></td></tr></table></figure>
<h4 id="14httpglideurlloaderbuildloaddata">14）HttpGlideUrlLoader#buildLoadData</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public LoadData&lt;InputStream&gt; buildLoadData(</span><br><span class="line">      @NonNull GlideUrl model, int width, int height, @NonNull Options options) &#123;</span><br><span class="line">    // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time</span><br><span class="line">    // spent parsing urls.</span><br><span class="line">    GlideUrl url = model;</span><br><span class="line">    if (modelCache != null) &#123;</span><br><span class="line">      url = modelCache.get(model, 0, 0);</span><br><span class="line">      if (url == null) &#123;</span><br><span class="line">        modelCache.put(model, 0, 0, model);</span><br><span class="line">        url = model;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int timeout = options.get(TIMEOUT);</span><br><span class="line">    return new LoadData&lt;&gt;(url, new HttpUrlFetcher(url, timeout));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   这里看到是返回的一个<code>HttpUrlFetcher</code>加载器，此时加载器拿到了之后我们来看它的<code>loadData</code>代码。</p>
<h4 id="15httpurlfetcherloaddata">15）HttpUrlFetcher#loadData</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void loadData(</span><br><span class="line">      @NonNull Priority priority, @NonNull DataCallback&lt;? super InputStream&gt; callback) &#123;</span><br><span class="line">    long startTime = LogTime.getLogTime();</span><br><span class="line">    try &#123;</span><br><span class="line">      //http 请求，返回一个 InputStream 输入流</span><br><span class="line">      InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());</span><br><span class="line">      //将 InputStream 以回调形式回调出去</span><br><span class="line">      callback.onDataReady(result);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      if (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, &quot;Failed to load data for url&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line">      callback.onLoadFailed(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        Log.v(TAG, &quot;Finished http url fetcher fetch in &quot; + LogTime.getElapsedMillis(startTime));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>loadDataWithRedirects</code>中会继续执行<code>buildAndConfigureConnection</code>方法，这里将<code>HttpURLConnection</code>作为网络请求，在请求成功之后会返回一个<code>InputStream</code>，最后会通过<code>onDataReady</code>回调到 <code>SourceGenerator</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void startNextLoad(final LoadData&lt;?&gt; toStart) &#123;</span><br><span class="line">    loadData.fetcher.loadData(</span><br><span class="line">        helper.getPriority(),</span><br><span class="line">        new DataCallback&lt;Object&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onDataReady(@Nullable Object data) &#123;</span><br><span class="line">            if (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onDataReadyInternal(toStart, data);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onLoadFailed(@NonNull Exception e) &#123;</span><br><span class="line">            if (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onLoadFailedInternal(toStart, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>SourceGenerator</code>的<code>startNextLoad</code>方法中会调用<code>onDataReadyInternal</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Synthetic</span><br><span class="line">  void onDataReadyInternal(LoadData&lt;?&gt; loadData, Object data) &#123;</span><br><span class="line">    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</span><br><span class="line">    if (data != null &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">      dataToCache = data;</span><br><span class="line">      // We might be being called back on someone else&apos;s thread. Before doing anything, we should</span><br><span class="line">      // reschedule to get back onto Glide&apos;s thread.</span><br><span class="line">      cb.reschedule();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cb.onDataFetcherReady(</span><br><span class="line">          loadData.sourceKey,</span><br><span class="line">          data,</span><br><span class="line">          loadData.fetcher,</span><br><span class="line">          loadData.fetcher.getDataSource(),</span><br><span class="line">          originalKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   这里因为我们没有配置缓存策略，所以走else，执行<code>cb.onDataFetcherReady</code>方法，这个cb是前面我们<code>new SourceGenerator</code>对象传入的 <code>DecodeJob</code>对象，也就是会调用<code>DecodeJob</code>对象<code>onDataFetcherReady</code>方法。</p>
<h4 id="16decodejobondatafetcherready">16）DecodeJob#onDataFetcherReady</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class DecodeJob&lt;R&gt;</span><br><span class="line">    implements DataFetcherGenerator.FetcherReadyCallback,</span><br><span class="line">        Runnable,</span><br><span class="line">        Comparable&lt;DecodeJob&lt;?&gt;&gt;,</span><br><span class="line">        Poolable &#123;</span><br><span class="line">            @Override</span><br><span class="line">              public void onDataFetcherReady(</span><br><span class="line">                  Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey) &#123;</span><br><span class="line">                  //当前返回数据的 key</span><br><span class="line">                this.currentSourceKey = sourceKey;</span><br><span class="line">                //返回的数据</span><br><span class="line">                this.currentData = data;</span><br><span class="line">                //返回的数据执行器</span><br><span class="line">                this.currentFetcher = fetcher;</span><br><span class="line">                //数据来源 url</span><br><span class="line">                this.currentDataSource = dataSource;</span><br><span class="line">                this.currentAttemptingKey = attemptedKey;</span><br><span class="line">                this.isLoadingFromAlternateCacheKey = sourceKey != decodeHelper.getCacheKeys().get(0);</span><br><span class="line"></span><br><span class="line">                if (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">                  runReason = RunReason.DECODE_DATA;</span><br><span class="line">                  callback.reschedule(this);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                  GlideTrace.beginSection(&quot;DecodeJob.decodeFromRetrievedData&quot;);</span><br><span class="line">                  try &#123;</span><br><span class="line">                    //解析返回回来的数据</span><br><span class="line">                    decodeFromRetrievedData();</span><br><span class="line">                  &#125; finally &#123;</span><br><span class="line">                    GlideTrace.endSection();</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>onDataFetcherReady</code>方法中将网络请求得到的数据流赋值给当前的<code>DecodeJob</code>对象的<code>currentData</code>，最终调用的是<code>decodeFromRetrievedData</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void decodeFromRetrievedData() &#123;</span><br><span class="line">    Resource&lt;R&gt; resource = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      //第一步骤：调用decodeFromData解析HttpUrlFetcher、InputStream、currentDataSource</span><br><span class="line">      resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">    &#125; catch (GlideException e) &#123;</span><br><span class="line">      e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">      throwables.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    if (resource != null) &#123;</span><br><span class="line">      //第二步骤：解码完成通知</span><br><span class="line">      notifyEncodeAndRelease(resource, currentDataSource, isLoadingFromAlternateCacheKey);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      runGenerators();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   然后继续跟踪<code>decodeFromData</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  private &lt;Data&gt; Resource&lt;R&gt; decodeFromData(</span><br><span class="line">    DataFetcher&lt;?&gt; fetcher, Data data, DataSource dataSource) throws GlideException &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    if (data == null) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    long startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);</span><br><span class="line">    if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      logWithTimeAndKey(&quot;Decoded result &quot; + result, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    fetcher.cleanup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private &lt;Data&gt; Resource&lt;R&gt; decodeFromFetcher(Data data, DataSource dataSource)</span><br><span class="line">      throws GlideException &#123;</span><br><span class="line">      //获取当前数据类的解析器LoadPath</span><br><span class="line">    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());</span><br><span class="line">    return runLoadPath(data, dataSource, path);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  private &lt;Data, ResourceType&gt; Resource&lt;R&gt; runLoadPath(</span><br><span class="line">        Data data, DataSource dataSource, LoadPath&lt;Data, ResourceType, R&gt; path)</span><br><span class="line">        throws GlideException &#123;</span><br><span class="line">      Options options = getOptionsWithHardwareConfig(dataSource);</span><br><span class="line">      //这里拿到的是InputStreamRewinder</span><br><span class="line">      DataRewinder&lt;Data&gt; rewinder = glideContext.getRegistry().getRewinder(data);</span><br><span class="line">      try &#123;</span><br><span class="line">        // ResourceType in DecodeCallback below is required for compilation to work with gradle.</span><br><span class="line">        //将解析资源的任务转移到path.load方法中</span><br><span class="line">        return path.load(</span><br><span class="line">            rewinder, options, width, height, new DecodeCallback&lt;ResourceType&gt;(dataSource));</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        rewinder.cleanup();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>decodeFromFetcher</code>方法中首先通过<code>decodeHelper.getLoadPath</code>获取<code>LoadPath</code>对象，<code>LoadPath</code>对象其实是根据传入的数据来返回特定的数据解码处理器。接下来调用了<code>runLoadPath</code>方法，创建一个<code>InputStreamRewinder</code>类型的<code>DataRewinder</code>，最后将这些参数传递到<code>path.load</code>中去。</p>
<h4 id="17loadpathload">17）LoadPath#load</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public Resource&lt;Transcode&gt; load(</span><br><span class="line">      DataRewinder&lt;Data&gt; rewinder,</span><br><span class="line">      @NonNull Options options,</span><br><span class="line">      int width,</span><br><span class="line">      int height,</span><br><span class="line">      DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback)</span><br><span class="line">      throws GlideException &#123;</span><br><span class="line">    List&lt;Throwable&gt; throwables = Preconditions.checkNotNull(listPool.acquire());</span><br><span class="line">    try &#123;</span><br><span class="line">      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      listPool.release(throwables);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">private Resource&lt;Transcode&gt; loadWithExceptionList(</span><br><span class="line">    DataRewinder&lt;Data&gt; rewinder,</span><br><span class="line">    @NonNull Options options,</span><br><span class="line">    int width,</span><br><span class="line">    int height,</span><br><span class="line">    DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback,</span><br><span class="line">    List&lt;Throwable&gt; exceptions)</span><br><span class="line">    throws GlideException &#123;</span><br><span class="line">  Resource&lt;Transcode&gt; result = null;</span><br><span class="line">  //遍历内部存储的 DecodePath 集合，通过他们来解析数据</span><br><span class="line">  for (int i = 0, size = decodePaths.size(); i &lt; size; i++) &#123;</span><br><span class="line">    DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i);</span><br><span class="line">    try &#123;</span><br><span class="line">      //解析数据</span><br><span class="line">      result = path.decode(rewinder, width, height, options, decodeCallback);</span><br><span class="line">    &#125; catch (GlideException e) &#123;</span><br><span class="line">      exceptions.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    if (result != null) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (result == null) &#123;</span><br><span class="line">    throw new GlideException(failureMessage, new ArrayList&lt;&gt;(exceptions));</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   在<code>loadWithExceptionList</code>方法中会遍历<code>decodePaths</code>数组，执行<code>decode</code>方法，找个才是真正解析数据的地方。</p>
<h4 id="18decodepathdecode">18）DecodePath#decode</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Resource&lt;Transcode&gt; decode(</span><br><span class="line">      DataRewinder&lt;DataType&gt; rewinder,</span><br><span class="line">      int width,</span><br><span class="line">      int height,</span><br><span class="line">      @NonNull Options options,</span><br><span class="line">      DecodeCallback&lt;ResourceType&gt; callback)</span><br><span class="line">      throws GlideException &#123;</span><br><span class="line">      //调用decodeResource解析数据</span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">    //回调</span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">    return transcoder.transcode(transformed, options);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   接下来我们来看一下<code>decodeResource</code>做了哪些操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  private Resource&lt;ResourceType&gt; decodeResource(</span><br><span class="line">      DataRewinder&lt;DataType&gt; rewinder, int width, int height, @NonNull Options options)</span><br><span class="line">      throws GlideException &#123;</span><br><span class="line">      ...</span><br><span class="line">      return decodeResourceWithList(rewinder, width, height, options, exceptions);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  @NonNull</span><br><span class="line">    private Resource&lt;ResourceType&gt; decodeResourceWithList(</span><br><span class="line">        DataRewinder&lt;DataType&gt; rewinder,</span><br><span class="line">        int width,</span><br><span class="line">        int height,</span><br><span class="line">        @NonNull Options options,</span><br><span class="line">        List&lt;Throwable&gt; exceptions)</span><br><span class="line">        throws GlideException &#123;</span><br><span class="line">      Resource&lt;ResourceType&gt; result = null;</span><br><span class="line">      for (int i = 0, size = decoders.size(); i &lt; size; i++) &#123;</span><br><span class="line">        ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);</span><br><span class="line">        try &#123;</span><br><span class="line">          // 获取包装的数据</span><br><span class="line">          DataType data = rewinder.rewindAndGet();</span><br><span class="line">          if (decoder.handles(data, options)) &#123;</span><br><span class="line">            data = rewinder.rewindAndGet();</span><br><span class="line">            // 根据DataType和ResourceType的类型分发给不同的解码器Decoder</span><br><span class="line">            result = decoder.decode(data, width, height, options);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        //省略</span><br><span class="line">        ........</span><br><span class="line">      &#125;</span><br><span class="line">      if (result == null) &#123;</span><br><span class="line">        throw new GlideException(failureMessage, new ArrayList&lt;&gt;(exceptions));</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>decodeResource</code>会调用<code>decodeResourceWithList</code>方法，<code>decodeResourceWithList</code>中会根据<code>DataType</code>和<code>ResourceType</code>的类型，来分发给不同的解码器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface ResourceDecoder&lt;T, Z&gt; &#123;</span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">  @Nullable</span><br><span class="line">  Resource&lt;Z&gt; decode(@NonNull T source, int width, int height, @NonNull Options options)</span><br><span class="line">      throws IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//StreamBitmapDecoder的decode</span><br><span class="line">@Override</span><br><span class="line">public Resource&lt;Bitmap&gt; decode(@NonNull InputStream source, int width, int height,</span><br><span class="line">    @NonNull Options options)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line"></span><br><span class="line">  // Use to fix the mark limit to avoid allocating buffers that fit entire images.</span><br><span class="line">  final RecyclableBufferedInputStream bufferedStream;</span><br><span class="line">  final boolean ownsBufferedStream;</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line">    </span><br><span class="line">  try &#123;</span><br><span class="line">    // 根据请求配置来对数据进行采样压缩，获取一个 Resource&lt;Bitmap&gt; </span><br><span class="line">    return downsampler.decode(invalidatingStream, width, height, options, callbacks);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   这里的<code>decode</code>是接口类方法，由于我们这里的源数据是<code>InputStream</code>，所以这里实际上调用的解码类是<code>StreamBitmapDecoder</code>。<code>StreamBitmapDecoder</code>的<code>decode</code>方法就是将<code>InputStream</code>流转换成<code>bitmap</code>对象。里面具体的实现细节我们暂时先不管他，先回到主线上来，所以接下来我们再重新回到<code>DecodePath</code>的<code>decode</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Resource&lt;Transcode&gt; decode(</span><br><span class="line">      DataRewinder&lt;DataType&gt; rewinder,</span><br><span class="line">      int width,</span><br><span class="line">      int height,</span><br><span class="line">      @NonNull Options options,</span><br><span class="line">      DecodeCallback&lt;ResourceType&gt; callback)</span><br><span class="line">      throws GlideException &#123;</span><br><span class="line">      //调用decodeResource解析数据，返回Bitmap</span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">    //解析完后数据回调</span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">    //Bitmap转换资源为Drawable</span><br><span class="line">    return transcoder.transcode(transformed, options);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   拿到<code>decoded</code>之后，调用<code>callback.onResourceDecoded(decoded)</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Resource&lt;Z&gt; onResourceDecoded(@NonNull Resource&lt;Z&gt; decoded) &#123;</span><br><span class="line">      return DecodeJob.this.onResourceDecoded(dataSource, decoded);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>onResourceDecoded</code>方法会调用<code>DecodeJob.this.onResourceDecoded()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Synthetic</span><br><span class="line">  @NonNull</span><br><span class="line">  &lt;Z&gt; Resource&lt;Z&gt; onResourceDecoded(DataSource dataSource, @NonNull Resource&lt;Z&gt; decoded) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    //获取资源类型</span><br><span class="line">    Class&lt;Z&gt; resourceSubClass = (Class&lt;Z&gt;) decoded.get().getClass();</span><br><span class="line">    Transformation&lt;Z&gt; appliedTransformation = null;</span><br><span class="line">    Resource&lt;Z&gt; transformed = decoded;</span><br><span class="line">    //如果不是从磁盘资源中获取需要进行 transform 操作</span><br><span class="line">    if (dataSource != DataSource.RESOURCE_DISK_CACHE) &#123;</span><br><span class="line">      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);</span><br><span class="line">      transformed = appliedTransformation.transform(glideContext, decoded, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    // TODO: Make this the responsibility of the Transformation.</span><br><span class="line">    if (!decoded.equals(transformed)) &#123;</span><br><span class="line">      decoded.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构建数据编码的策略</span><br><span class="line">    final EncodeStrategy encodeStrategy;</span><br><span class="line">    final ResourceEncoder&lt;Z&gt; encoder;</span><br><span class="line">    if (decodeHelper.isResourceEncoderAvailable(transformed)) &#123;</span><br><span class="line">      encoder = decodeHelper.getResultEncoder(transformed);</span><br><span class="line">      encodeStrategy = encoder.getEncodeStrategy(options);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      encoder = null;</span><br><span class="line">      encodeStrategy = EncodeStrategy.NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    //根据编码策略，构建缓存 Key</span><br><span class="line">    Resource&lt;Z&gt; result = transformed;</span><br><span class="line">    boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);</span><br><span class="line">    if (diskCacheStrategy.isResourceCacheable(</span><br><span class="line">        isFromAlternateCacheKey, dataSource, encodeStrategy)) &#123;</span><br><span class="line">      if (encoder == null) &#123;</span><br><span class="line">        throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      final Key key;</span><br><span class="line">      switch (encodeStrategy) &#123;</span><br><span class="line">        case SOURCE:</span><br><span class="line">          key = new DataCacheKey(currentSourceKey, signature);</span><br><span class="line">          break;</span><br><span class="line">        case TRANSFORMED:</span><br><span class="line">          key =</span><br><span class="line">              new ResourceCacheKey(</span><br><span class="line">                  decodeHelper.getArrayPool(),</span><br><span class="line">                  currentSourceKey,</span><br><span class="line">                  signature,</span><br><span class="line">                  width,</span><br><span class="line">                  height,</span><br><span class="line">                  appliedTransformation,</span><br><span class="line">                  resourceSubClass,</span><br><span class="line">                  options);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          throw new IllegalArgumentException(&quot;Unknown strategy: &quot; + encodeStrategy);</span><br><span class="line">      &#125;</span><br><span class="line">      //初始化编码管理者，用于提交内存缓存</span><br><span class="line">      LockedResource&lt;Z&gt; lockedResult = LockedResource.obtain(transformed);</span><br><span class="line">      deferredEncodeManager.init(key, encoder, lockedResult);</span><br><span class="line">      result = lockedResult;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回转换后的 Bitmap</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>callback.onResourceDecoded(decoded)</code>返回<code>transformed</code>后，接下来我们看的<code>decode</code>方法的最后一步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Resource&lt;Transcode&gt; decode(</span><br><span class="line">      DataRewinder&lt;DataType&gt; rewinder,</span><br><span class="line">      int width,</span><br><span class="line">      int height,</span><br><span class="line">      @NonNull Options options,</span><br><span class="line">      DecodeCallback&lt;ResourceType&gt; callback)</span><br><span class="line">      throws GlideException &#123;</span><br><span class="line">      //调用decodeResource解析数据，返回Bitmap</span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">    //解析完后数据回调</span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">    //Bitmap转换资源为Drawable</span><br><span class="line">    return transcoder.transcode(transformed, options);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>transcoder.transcode(transformed, options)</code>方法执行的是<code>ResourceTranscoder</code>接口的<code>transcode</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface ResourceTranscoder&lt;Z, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Transcodes the given resource to the new resource type and returns the new resource.</span><br><span class="line">   *</span><br><span class="line">   * @param toTranscode The resource to transcode.</span><br><span class="line">   */</span><br><span class="line">  @Nullable</span><br><span class="line">  Resource&lt;R&gt; transcode(@NonNull Resource&lt;Z&gt; toTranscode, @NonNull Options options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   因为解析完的数据是<code>Bitmap</code>所以它的实现类是<code>BitmapDrawableTranscoder</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">  @Override</span><br><span class="line">  public Resource&lt;BitmapDrawable&gt; transcode(</span><br><span class="line">      @NonNull Resource&lt;Bitmap&gt; toTranscode, @NonNull Options options) &#123;</span><br><span class="line">    return LazyBitmapDrawableResource.obtain(resources, toTranscode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//LazyBitmapDrawableResource</span><br><span class="line">public final class LazyBitmapDrawableResource implements Resource&lt;BitmapDrawable&gt;, Initializable &#123;</span><br><span class="line"></span><br><span class="line">  private final Resources resources;</span><br><span class="line">  private final Resource&lt;Bitmap&gt; bitmapResource;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @deprecated Use &#123;@link #obtain(Resources, Resource)&#125; instead, it can be unsafe to extract</span><br><span class="line">   *     &#123;@link Bitmap&#125;s from their wrapped &#123;@link Resource&#125;.</span><br><span class="line">   */</span><br><span class="line">  @Deprecated</span><br><span class="line">  public static LazyBitmapDrawableResource obtain(Context context, Bitmap bitmap) &#123;</span><br><span class="line">    return (LazyBitmapDrawableResource)</span><br><span class="line">        obtain(</span><br><span class="line">            context.getResources(),</span><br><span class="line">            BitmapResource.obtain(bitmap, Glide.get(context).getBitmapPool()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @deprecated Use &#123;@link #obtain(Resources, Resource)&#125; instead, it can be unsafe to extract</span><br><span class="line">   *     &#123;@link Bitmap&#125;s from their wrapped &#123;@link Resource&#125;.</span><br><span class="line">   */</span><br><span class="line">  @Deprecated</span><br><span class="line">  public static LazyBitmapDrawableResource obtain(</span><br><span class="line">      Resources resources, BitmapPool bitmapPool, Bitmap bitmap) &#123;</span><br><span class="line">    return (LazyBitmapDrawableResource)</span><br><span class="line">        obtain(resources, BitmapResource.obtain(bitmap, bitmapPool));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Nullable</span><br><span class="line">  public static Resource&lt;BitmapDrawable&gt; obtain(</span><br><span class="line">      @NonNull Resources resources, @Nullable Resource&lt;Bitmap&gt; bitmapResource) &#123;</span><br><span class="line">    if (bitmapResource == null) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return new LazyBitmapDrawableResource(resources, bitmapResource);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private LazyBitmapDrawableResource(</span><br><span class="line">      @NonNull Resources resources, @NonNull Resource&lt;Bitmap&gt; bitmapResource) &#123;</span><br><span class="line">    this.resources = Preconditions.checkNotNull(resources);</span><br><span class="line">    this.bitmapResource = Preconditions.checkNotNull(bitmapResource);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> //Get方法反回了BitmapDrawable对象</span><br><span class="line">  @NonNull</span><br><span class="line">  @Override</span><br><span class="line">  public BitmapDrawable get() &#123;</span><br><span class="line">    return new BitmapDrawable(resources, bitmapResource.get());</span><br><span class="line">  &#125;</span><br><span class="line">  .....</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   <code>BitmapDrawableTranscoder</code>的<code>transcode</code>会调用<code>LazyBitmapDrawableResource. obtain(resources, toTranscode)</code>，然后在<code>obtain</code>中继续调用<code>new LazyBitmapDrawable-Resource(resources, bitmapResource)</code>，将<code>Bitmap</code>资源转换为<code>Resource&lt;Bitmap&gt;</code>对象存放到<code>LazyBitmapDrawableResource</code>内部。接下来我们继续回到<code>decodeFromRetrievedData</code>的第二步骤。</p>
<h4 id="19decodejobdecodefromretrieveddata">19）DecodeJob#decodeFromRetrievedData</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void decodeFromRetrievedData() &#123;</span><br><span class="line">    Resource&lt;R&gt; resource = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      //第一步骤：调用decodeFromData解析HttpUrlFetcher、InputStream、currentDataSource</span><br><span class="line">      resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">    &#125; catch (GlideException e) &#123;</span><br><span class="line">      e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">      throwables.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    if (resource != null) &#123;</span><br><span class="line">      //第二步骤：解码完成通知</span><br><span class="line">      notifyEncodeAndRelease(resource, currentDataSource, isLoadingFromAlternateCacheKey);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      runGenerators();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   此时<code>resource</code>不为空，则进入到<code>notifyEncodeAndRelease</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void notifyEncodeAndRelease(</span><br><span class="line">      Resource&lt;R&gt; resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) &#123;</span><br><span class="line">    GlideTrace.beginSection(&quot;DecodeJob.notifyEncodeAndRelease&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">      ...</span><br><span class="line">      notifyComplete(result, dataSource, isLoadedFromAlternateCacheKey);</span><br><span class="line"></span><br><span class="line">      stage = Stage.ENCODE;</span><br><span class="line">      try &#123;</span><br><span class="line">        //将资源磁盘缓存</span><br><span class="line">        if (deferredEncodeManager.hasResourceToEncode()) &#123;</span><br><span class="line">          deferredEncodeManager.encode(diskCacheProvider, options);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      //完成</span><br><span class="line">      onEncodeComplete();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      GlideTrace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private void notifyComplete(</span><br><span class="line">      Resource&lt;R&gt; resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) &#123;</span><br><span class="line">    setNotifiedOrThrow();</span><br><span class="line">    callback.onResourceReady(resource, dataSource, isLoadedFromAlternateCacheKey);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>notifyEncodeAndRelease</code>方法将解析后返回的数据放到<code>notifyComplete</code>中，同时如果配置了本地缓存，就缓存到磁盘。<code>notifyComplete</code>调用<code>callback.onResourceReady()</code>进行回调，这里的<code>callback</code>就是<code>EngineJob</code>，最后<code>onEncodeComplete</code>通知完成。接下来我们来看<code>EngineJob</code>中的<code>onResourceReady</code>方法。</p>
<h4 id="20enginejobonresourceready">20）EngineJob#onResourceReady</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void onResourceReady(</span><br><span class="line">      Resource&lt;R&gt; resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      this.resource = resource;</span><br><span class="line">      this.dataSource = dataSource;</span><br><span class="line">      this.isLoadedFromAlternateCacheKey = isLoadedFromAlternateCacheKey;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyCallbacksOfResult();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Synthetic</span><br><span class="line">    void notifyCallbacksOfResult() &#123;</span><br><span class="line">      ResourceCallbacksAndExecutors copy;</span><br><span class="line">      Key localKey;</span><br><span class="line">      EngineResource&lt;?&gt; localResource;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">        stateVerifier.throwIfRecycled();</span><br><span class="line">        if (isCancelled) &#123;</span><br><span class="line">          resource.recycle();</span><br><span class="line">          release();</span><br><span class="line">          return;</span><br><span class="line">        &#125; else if (cbs.isEmpty()) &#123;</span><br><span class="line">          throw new IllegalStateException(&quot;Received a resource without any callbacks to notify&quot;);</span><br><span class="line">        &#125; else if (hasResource) &#123;</span><br><span class="line">          throw new IllegalStateException(&quot;Already have resource&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        engineResource = engineResourceFactory.build(resource, isCacheable, key, resourceListener);</span><br><span class="line">        hasResource = true;</span><br><span class="line">        copy = cbs.copy();</span><br><span class="line">        incrementPendingCallbacks(copy.size() + 1);</span><br><span class="line"></span><br><span class="line">        localKey = key;</span><br><span class="line">        localResource = engineResource;</span><br><span class="line">      &#125;</span><br><span class="line">      //回调上层 Engine 任务完成了</span><br><span class="line">      engineJobListener.onEngineJobComplete(this, localKey, localResource);</span><br><span class="line">      </span><br><span class="line">      //遍历资源给ImageViewTarget</span><br><span class="line">      for (final ResourceCallbackAndExecutor entry : copy) &#123;</span><br><span class="line">        entry.executor.execute(new CallResourceReady(entry.cb));</span><br><span class="line">      &#125;</span><br><span class="line">      decrementPendingCallbacks();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>onResourceReady</code>主要调用了<code>notifyCallbacksOfResult</code>方法。通过<code>onEngineJobComplete</code>来回调成功，之后将资源发给<code>ImageViewTarget</code>。然后接下来我们来看<code>onEngineJobComplete</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">@Override</span><br><span class="line">public synchronized void onEngineJobComplete(</span><br><span class="line">    EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource) &#123;</span><br><span class="line">  // A null resource indicates that the load failed, usually due to an exception.</span><br><span class="line">  if (resource != null &amp;&amp; resource.isMemoryCacheable()) &#123;</span><br><span class="line">    //收到下游返回回来的资源，添加到活动缓存中</span><br><span class="line">    activeResources.activate(key, resource);</span><br><span class="line">  &#125;</span><br><span class="line">  jobs.removeIfCurrent(key, engineJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   然后看<code>entry.executor.execute(new CallResourceReady(entry.cb))</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private class CallResourceReady implements Runnable &#123;</span><br><span class="line">  private final ResourceCallback cb;</span><br><span class="line"></span><br><span class="line">  CallResourceReady(ResourceCallback cb) &#123;</span><br><span class="line">    this.cb = cb;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    synchronized (cb.getLock()) &#123;</span><br><span class="line">      synchronized (EngineJob.this) &#123;</span><br><span class="line">        if (cbs.contains(cb)) &#123;</span><br><span class="line">          engineResource.acquire();</span><br><span class="line">          callCallbackOnResourceReady(cb);</span><br><span class="line">          removeCallback(cb);</span><br><span class="line">        &#125;</span><br><span class="line">        decrementPendingCallbacks();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   调用<code>callCallbackOnResourceReady</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;)</span><br><span class="line">@Synthetic</span><br><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">void callCallbackOnResourceReady(ResourceCallback cb) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    cb.onResourceReady(engineResource, dataSource, isLoadedFromAlternateCacheKey);</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">    throw new CallbackException(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   <code>callCallbackOnResourceReady</code>方法调用<code>cb.onResourceReady()</code>，这里的cb其实是<code>SingleRequest</code>，接下来我们看<code>SingleRequest</code>的<code>onResourceReady</code>。</p>
<h4 id="21singlerequestonresourceready">21）SingleRequest#onResourceReady</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">@Override</span><br><span class="line">public void onResourceReady(</span><br><span class="line">    Resource&lt;?&gt; resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) &#123;</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  Resource&lt;?&gt; toRelease = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    synchronized (requestLock) &#123;</span><br><span class="line">      loadStatus = null;</span><br><span class="line">      if (resource == null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        onLoadFailed(exception);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Object received = resource.get();</span><br><span class="line">      if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) &#123;</span><br><span class="line">        toRelease = resource;</span><br><span class="line">        this.resource = null;</span><br><span class="line">        ...</span><br><span class="line">        onLoadFailed(exception);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!canSetResource()) &#123;</span><br><span class="line">        toRelease = resource;</span><br><span class="line">        this.resource = null;</span><br><span class="line">        // We can&apos;t put the status to complete before asking canSetResource().</span><br><span class="line">        status = Status.COMPLETE;</span><br><span class="line">        GlideTrace.endSectionAsync(TAG, cookie);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //当资源准备好的时候</span><br><span class="line">      onResourceReady(</span><br><span class="line">          (Resource&lt;R&gt;) resource, (R) received, dataSource, isLoadedFromAlternateCacheKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&#123;&quot;deprecation&quot;, &quot;PMD.UnusedFormalParameter&quot;&#125;)</span><br><span class="line">  @GuardedBy(&quot;requestLock&quot;)</span><br><span class="line">  private void onResourceReady(</span><br><span class="line">      Resource&lt;R&gt; resource, R result, DataSource dataSource, boolean isAlternateCacheKey) &#123;</span><br><span class="line">    boolean isFirstResource = isFirstReadyResource();</span><br><span class="line">    status = Status.COMPLETE;</span><br><span class="line">    this.resource = resource;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    isCallingCallbacks = true;</span><br><span class="line">    try &#123;</span><br><span class="line">      boolean anyListenerHandledUpdatingTarget = false;</span><br><span class="line">      ...</span><br><span class="line">      anyListenerHandledUpdatingTarget |=</span><br><span class="line">          targetListener != null</span><br><span class="line">              &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);</span><br><span class="line"></span><br><span class="line">      if (!anyListenerHandledUpdatingTarget) &#123;</span><br><span class="line">        Transition&lt;? super R&gt; animation = animationFactory.build(dataSource, isFirstResource);</span><br><span class="line">        //回调给ImageViewTarget，表示资源准备好了</span><br><span class="line">        target.onResourceReady(result, animation);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      isCallingCallbacks = false;</span><br><span class="line">    &#125;</span><br><span class="line">    //加载成功</span><br><span class="line">    notifyLoadSuccess();</span><br><span class="line">    GlideTrace.endSectionAsync(TAG, cookie);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   <code>onResourceReady</code>方法，最终会调用<code>target</code>的<code>onResourceReady</code>方法，这里的<code>target</code>就是一开始的<code>ImageViewTarget</code>。接下来看<code>ImageViewTarget</code>的<code>onResourceReady</code>方法。</p>
<h4 id="22imageviewtargetonresourceready">22）ImageViewTarget#onResourceReady</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void onResourceReady(@NonNull Z resource, @Nullable Transition&lt;? super Z&gt; transition) &#123;</span><br><span class="line">    if (transition == null || !transition.transition(resource, this)) &#123;</span><br><span class="line">      setResourceInternal(resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      maybeUpdateAnimatable(resource);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private void setResourceInternal(@Nullable Z resource) &#123;</span><br><span class="line">  //调用setResource函数，显示图片</span><br><span class="line">  setResource(resource);</span><br><span class="line">  maybeUpdateAnimatable(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected abstract void setResource(@Nullable Z resource);</span><br></pre></td></tr></table></figure>
<p>   <code>setResource</code>在<code>ImageViewTarget</code>对象是抽象方法，还记得在一开始<code>load</code>的时候，加载的是<code>asDrawable()</code>方法，所以此时它在<code>DrawableImageViewTarget</code>对象中实现。最后我们来看一下<code>DrawableImageViewTarget</code>的<code>setResource</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DrawableImageViewTarget extends ImageViewTarget&lt;Drawable&gt; &#123;</span><br><span class="line"></span><br><span class="line">  public DrawableImageViewTarget(ImageView view) &#123;</span><br><span class="line">    super(view);</span><br><span class="line">  &#125;</span><br><span class="line">  @SuppressWarnings(&#123;&quot;unused&quot;, &quot;deprecation&quot;&#125;)</span><br><span class="line">  @Deprecated</span><br><span class="line">  public DrawableImageViewTarget(ImageView view, boolean waitForLayout) &#123;</span><br><span class="line">    super(view, waitForLayout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void setResource(@Nullable Drawable resource) &#123;</span><br><span class="line">    //设置图片</span><br><span class="line">    view.setImageDrawable(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   调用完<code>view.setImageDrawable(resource)</code>，图片才算真正显示出来了，到这一步才算结束了。</p>
<h2 id="三-总结">三、总结</h2>
<p>   总的来说glide的源码的代码量真的非常多，背后的代码细节也很复杂，一行行看下来的话可能会被绕晕过去，这里只是将加载流程分析了一遍。所以看的时候应该抓住最主要的线来进行分析，只有把整体结构理清楚了，后面的一些细节才会和主线关联起来。</p>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/glide-analyze-2/" data-toggle="tooltip" data-placement="top" title="Glide源码解析（二）">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/algorithm-narrowSingle/" data-toggle="tooltip" data-placement="top" title="多边形的内缩算法（二）—单边内缩">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#一-前言"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">&#x4E00;&#x3001;&#x524D;&#x8A00;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1基本加载流程"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">1.&#x57FA;&#x672C;&#x52A0;&#x8F7D;&#x6D41;&#x7A0B;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#二-加载流程解析"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">&#x4E8C;&#x3001;&#x52A0;&#x8F7D;&#x6D41;&#x7A0B;&#x89E3;&#x6790;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1with-方法"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">1.with( )&#x65B9;&#x6CD5;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1with"><span class="toc-nav-number">2.1.1.</span> <span class="toc-nav-text">1&#xFF09;With</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2glidemodule"><span class="toc-nav-number">2.1.2.</span> <span class="toc-nav-text">2&#xFF09;GlideModule</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3build"><span class="toc-nav-number">2.1.3.</span> <span class="toc-nav-text">3&#xFF09;Build</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4requestmanagerretrieverget"><span class="toc-nav-number">2.1.4.</span> <span class="toc-nav-text">4&#xFF09;RequestManagerRetriever#get</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5requestmanagerfragment"><span class="toc-nav-number">2.1.5.</span> <span class="toc-nav-text">5&#xFF09;RequestManagerFragment</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6with小结"><span class="toc-nav-number">2.1.6.</span> <span class="toc-nav-text">6&#xFF09;with&#x5C0F;&#x7ED3;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2load-方法"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">2.load( )&#x65B9;&#x6CD5;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1requestmanagerload"><span class="toc-nav-number">2.2.1.</span> <span class="toc-nav-text">1&#xFF09;RequestManager#load</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2requestmanagerasdrawable"><span class="toc-nav-number">2.2.2.</span> <span class="toc-nav-text">2&#xFF09;RequestManager#asDrawable</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3load小结"><span class="toc-nav-number">2.2.3.</span> <span class="toc-nav-text">3&#xFF09;load&#x5C0F;&#x7ED3;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3into-方法"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">3.into( )&#x65B9;&#x6CD5;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1requestbuilderinto"><span class="toc-nav-number">2.3.1.</span> <span class="toc-nav-text">1&#xFF09;RequestBuilder#into</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2buildimageviewtarget"><span class="toc-nav-number">2.3.2.</span> <span class="toc-nav-text">2&#xFF09;buildImageViewTarget</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3drawableimageviewtarget"><span class="toc-nav-number">2.3.3.</span> <span class="toc-nav-text">3&#xFF09;DrawableImageViewTarget</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4requestbuilderinto"><span class="toc-nav-number">2.3.4.</span> <span class="toc-nav-text">4&#xFF09;RequestBuilder#into</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5requestbuilderbuildrequest"><span class="toc-nav-number">2.3.5.</span> <span class="toc-nav-text">5&#xFF09;RequestBuilder#buildRequest</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6requestbuildertrack"><span class="toc-nav-number">2.3.6.</span> <span class="toc-nav-text">6&#xFF09;RequestBuilder#track</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#7singlerequestbegin"><span class="toc-nav-number">2.3.7.</span> <span class="toc-nav-text">7&#xFF09;SingleRequest#begin</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#8singlerequestonsizeready"><span class="toc-nav-number">2.3.8.</span> <span class="toc-nav-text">8&#xFF09;SingleRequest#onSizeReady</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#9engineload"><span class="toc-nav-number">2.3.9.</span> <span class="toc-nav-text">9&#xFF09;Engine#load</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#10enginewaitforexistingorstartnewjob"><span class="toc-nav-number">2.3.10.</span> <span class="toc-nav-text">10&#xFF09;Engine#waitForExistingOrStartNewJob</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#11decodejobrun"><span class="toc-nav-number">2.3.11.</span> <span class="toc-nav-text">11&#xFF09;DecodeJob#run</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#12sourcegeneratorstartnext"><span class="toc-nav-number">2.3.12.</span> <span class="toc-nav-text">12&#xFF09;SourceGenerator#startNext</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#13decodehelpergetloaddata"><span class="toc-nav-number">2.3.13.</span> <span class="toc-nav-text">13&#xFF09;DecodeHelper#getLoadData</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#14httpglideurlloaderbuildloaddata"><span class="toc-nav-number">2.3.14.</span> <span class="toc-nav-text">14&#xFF09;HttpGlideUrlLoader#buildLoadData</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#15httpurlfetcherloaddata"><span class="toc-nav-number">2.3.15.</span> <span class="toc-nav-text">15&#xFF09;HttpUrlFetcher#loadData</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#16decodejobondatafetcherready"><span class="toc-nav-number">2.3.16.</span> <span class="toc-nav-text">16&#xFF09;DecodeJob#onDataFetcherReady</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#17loadpathload"><span class="toc-nav-number">2.3.17.</span> <span class="toc-nav-text">17&#xFF09;LoadPath#load</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#18decodepathdecode"><span class="toc-nav-number">2.3.18.</span> <span class="toc-nav-text">18&#xFF09;DecodePath#decode</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#19decodejobdecodefromretrieveddata"><span class="toc-nav-number">2.3.19.</span> <span class="toc-nav-text">19&#xFF09;DecodeJob#decodeFromRetrievedData</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#20enginejobonresourceready"><span class="toc-nav-number">2.3.20.</span> <span class="toc-nav-text">20&#xFF09;EngineJob#onResourceReady</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#21singlerequestonresourceready"><span class="toc-nav-number">2.3.21.</span> <span class="toc-nav-text">21&#xFF09;SingleRequest#onResourceReady</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#22imageviewtargetonresourceready"><span class="toc-nav-number">2.3.22.</span> <span class="toc-nav-text">22&#xFF09;ImageViewTarget#onResourceReady</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#三-总结"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">&#x4E09;&#x3001;&#x603B;&#x7ED3;</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Android" title="Android">Android</a>
                        
                          <a class="tag" href="/tags/#Glide" title="Glide">Glide</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/Williamic">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Williamic 2021 
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://williamic.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
</body>

</html>
