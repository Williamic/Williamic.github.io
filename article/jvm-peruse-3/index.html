<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="8szEBDhTLveYnlc_8VLUBz22yXDk5GKI7ujb0PVRVMQ" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          深入理解JVM—垃圾收集器与内存分配策略 - 王威拓 | Blog
        
    </title>

    <link rel="canonical" href="https://williamic.github.io/article/jvm-peruse-3/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/header.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Jvm" title="Jvm">Jvm</a>
                            
                              <a class="tag" href="/tags/#Java" title="Java">Java</a>
                            
                        </div>
                        <h1>深入理解JVM—垃圾收集器与内存分配策略</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Williamic on
                            2019-12-18
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">王威拓</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h3 id="1对象存活判定">1.对象存活判定</h3>
<h4 id="1引用计数算法">1）引用计数算法</h4>
<p>   给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器的值就减1。当计数器为0的对象就是不再被使用的。<br>
   引用计数算法的实现简单，判定效率也很高，但是在主流的Java虚拟机里面没有选用它来管理内存，很大原因就是<strong>无法解决对象之间的相互循环引用的问题。</strong></p>
<h4 id="2可达性分析算法reachability-analysis">2）可达性分析算法（Reachability Analysis）</h4>
<p>   在主流的商用程序语言的主流实现中，都是通过可达性分析来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始往下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots<strong>没有任何引用链相连时，则证明此对象不可用。</strong><br>
   在Java语言中，可作为GC Roots的对象的包括以下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态熟悉引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
<h4 id="3引用的定义">3）引用的定义</h4>
<p>   在JKD1.2以前，Java中引用的定义是如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表一个引用。这种定义很纯粹，但是太过于狭隘。对于一些“食之无味，弃之可惜”的对象就显得无能为力，我们希望在内存空间还足够的时候，保留这样的对象，当内存空间进行垃圾收集后还非常紧张，则可以选择抛弃这些对象。<br>
   在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为了强引用、软引用、弱引用、虚引用这四种，它们的引用强度依次减弱。</p>
<ul>
<li>强引用（Strong Reference）：程序中普遍存在的引用，只要强引用还存在，垃圾收集器<strong>永远</strong>不会回收掉被引用的对象。</li>
<li>软引用（Soft Reference）：用来描述一些还有用但并非必需的对象。对于软引用关联着的对象在系统要发生内存溢出异常之前，会把这些对象列进回收范围之中进行<strong>二次回收</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。</li>
<li>弱引用（Weak Reference）：用来描述非必需对象，但是强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，<strong>无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。在JDK1.2之后，提供了WeakReference类来实现弱引用。</li>
<li>虚引用（Phantom Reference）：最弱的一种引用关系，不会对其生存时间构成影响，也无发通过虚引用来取得一个对象实例。对象设置虚引用关联的<strong>唯一目的是这个对象被垃圾收集器回收时会收到一个系统通知</strong>。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</li>
</ul>
<h4 id="4对象的回收判定">4）对象的回收判定</h4>
<p>   即使在可达性分析算法中不可达的对象，也并非“<strong>非死不可</strong>”，要宣告一个对象需要被回收，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连的引用链，那它会被第一次标记并且进行一次此对象是否有必要执行finalize()方法的筛选。<br>
   当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，此时虚拟机对该对象宣告死亡。<br>
   如果这个对象有必要执行finalize()方法，对象会被放置在一个F-Queue的队列中，并由一个虚拟机自动建立的、低优先级的Finalizer线程去执行。但是“执行”仅仅意味着虚拟机<strong>会触发这个方法，但不承诺会等待它运行结束</strong>，目的是如果一个对象在finalize()方法中执行缓慢（甚至发生了死循环），可能会导致F-Quene队列中其他对象处于等待，进而导致整个内存回收系统奔溃。<br>
   finalize()方法是对象逃离被回收命运的最后一次机会，稍后GC会对F-Queue中的对象进行第二次小规模标记，如果此时对象在finalize()中重新与引用链的任何一个对象建立关联，则可以被移出“即将回收”的集合，否则就会被回收。<br>
   任何一个对象的的finalize()方法都只会被系统调用一次，如果对象面临下一次回收，则它的finalize()方法不会被执行。</p>
<h4 id="5方法区hotspot虚拟机中的永久代的gc">5）方法区（HotSpot虚拟机中的永久代）的GC</h4>
<p>   在堆中，尤其是新生代中进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容：<strong>废弃常量和无用的类</strong>。</p>
<h5 id="-回收废弃常量">- 回收废弃常量</h5>
<p>   当一个常量已经进入了常量池，但是当前系统没有任何一个对象引用常量池中的常量，也没有任何地方引用这个字面量，如果这时发生内存回收，而且必要的话，这个常量就会被系统清理出常量池。</p>
<h5 id="-回收无用的类">- 回收无用的类</h5>
<p>   判定一个类是否是无用的类需要同时满足以下3个条件：</p>
<ul>
<li>该类所有的实例都已经被回收（Java堆中不存在该类的任何实例）。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>   虚拟机可以对满足上述3种判断条件的无用的类进行回收，但并不是和对象一样不使用了就必然会被回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类中加载和卸载信息。<br>
   在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证永久代不会溢出。</p>
<h3 id="2垃圾收集算法">2.垃圾收集算法</h3>
<h4 id="1标记-清除算法mark-sweep">1）标记-清除算法(Mark-Sweep)</h4>
<h5 id="-基本思路">- 基本思路</h5>
<p>   最基础的收集算法是“标记—清除”算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象。</p>
<h5 id="-缺点">- 缺点</h5>
<p>   它主要有两点不足：一个是效率问题，<strong>标记和清除的两个过程的效率都不高</strong>；另一个是标记清除后会<strong>产生大量的不连续的碎片</strong>，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时无法找到足够连续的内存而不得不提前触发另一次GC。</p>
<h4 id="2复制算法copying">2）复制算法(Copying)</h4>
<h5 id="-基本思路">- 基本思路</h5>
<p>   为解决效率问题，出现了复制算法。它将可用的内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完了之后就将还存活着的对象复制到另一块上面，然后把已经使用过的内存空间一次性清理掉。</p>
<h5 id="-优点">- 优点</h5>
<p>   优点是只对整个半区进行内存回收，内存分配时就不需要考虑内存碎片等问题，运行高效实现简单。</p>
<h5 id="-缺点">- 缺点</h5>
<p>   缺点是需要将内存缩小为原来的一半，需要的代价太高。</p>
<h4 id="3标记-整理算法mark-compact">3）标记-整理算法(Mark-Compact)</h4>
<h5 id="-基本思路">- 基本思路</h5>
<p>   根据老年代的特点（对象存活率较高，没有额外的空间对它进行分配担保），提出了一种适用于老年代的“标记—整理”算法。标记过程与“标记—清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h5 id="-优点">- 优点</h5>
<p>   相较于复制算法可以避免内存空间的浪费，避免在对象存活率较高的时候进行复制操作而导致的效率变低。</p>
<h4 id="4分代收集算法generational-collection">4）分代收集算法(Generational Collection)</h4>
<p>   当前商业虚拟机的垃圾收集都采用“分代收集”，根据不同对象的存活周期将内存划分为几块。一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集方法。</p>
<h5 id="-新生代的垃圾收集算法">- 新生代的垃圾收集算法</h5>
<p>   在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活。所以将内存划分为一块较大的Eden空间和两块较小的Survivor空间（HotSpot虚拟机默认Eden和Survivor大小比例是8：1），每次使用Eden空间和其中一块Survivor空间。当回收时将Eden和Survivor中还存活着的对象采用复制算法复制到另一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor空间。<br>
   如果另一块Survivor空间没有足够空间存放上一次新生代收集下来存活的对象时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion），这些对象将通过担保机制进入老年代。</p>
<h5 id="-老年代的垃圾收集算法">- 老年代的垃圾收集算法</h5>
<p>   老年代对象存活率高，如果进行复制收集算法就需要进行较多的复制操作，降低效率。且老年代没有额外的空间对它来进行分配担保，所以必须使用“标记-清除”或者“标记-整理”算法进行回收。</p>
<h3 id="3hotspot的算法实现">3.HotSpot的算法实现</h3>
<h4 id="1枚举根节点">1）枚举根节点</h4>
<p>   以可达性分析从GC Roots节点查找引用链为例，可作为GC Roots节点的主要在全局性的引用（常量或静态属性）与执行上下文（栈帧中的本地变量表）中，若逐条查找其中的引用，必然需要耗费很多时间。并且可达性分析对执行时间的敏感还体现在GC停顿上。</p>
<h5 id="-什么是gc停顿">- 什么是GC停顿</h5>
<p>   在分析对象可达性过程中需要分析工作在一个能确保一致性的快照中进行——即分析期间整个执行系统不能出现分析过程中对象引用关系还在不断的变化的情况，否则分析结果的准确性就无法得到保证。这是导致GC进行中必须停顿所有Java执行线程（“Stop The World”）的一个重要原因。</p>
<h5 id="-gc如何快速枚举根节点">- GC如何快速枚举根节点</h5>
<p>   因为在枚举根节点期间会发生STW，所以如果逐条检查引用必然会耗费大量的时间。目前主流的Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏的检查有执行上下文和全局的引用位置，虚拟机有办法知道哪些地方存放着对象的引用。在HotSpot的实现中，使用OopMap的数据结构来达到这个目的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>
<h4 id="2安全点">2）安全点</h4>
<p>   在现代JVM里，Safepoint有几种不同的用法。比如<strong>GC、Deoptimization</strong>，其中GC Safepoint是最常见的。在HotSpot VM里，这两种Safepoint目前实现在一起，但其实概念上它们俩没有直接联系，需要的数据不一样。这里主要介绍的是GC Safepoint。</p>
<h5 id="-什么是安全点">- 什么是安全点</h5>
<p>   Safepoint可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的。GC Safepoint则是在那个程序位置上，记录了调用栈、寄存器等一些重要的数据区域里什么地方包含了GC管理的指针。<strong>如果要触发一次GC，那么JVM里的所有Java线程都必须到达GC Safepoint</strong>。</p>
<h5 id="-安全点的位置选定">- 安全点的位置选定</h5>
<p>   不同的JVM会选取不同的位置来放置Safepoint。以HotSpot VM为例，在JIT编译过程中，不但会生成机器码，还会在每个Safepoint位置生成OopMap，用于记录下栈和寄存器中哪些位置是引用。<br>
   解释器的每条字节码的边界都可以是一个Safepoint，但之所以只在选定的位置放置Safepoint是因为：</p>
<ul>
<li>OopMap需要存储空间，如果为每条指令都生成对应的OopMap，需要存储的数据量会很大。</li>
<li>Safepoint会影响优化。特别是Deoptimization Safepoint，会迫使JVM保留一些只有解释器可能需要但JIT编译器认定无用的变量的值。本来JIT编译器可以发现某些值不需要而消除它们对应的运算，如果在Safepoint需要这些值那就只好保留了。</li>
<li>Safepoint会生成Polling代码询问VM是否要进入Safepoint，Polling也有开销所以要尽量减少。</li>
</ul>
<p>   所以Safepoint的选定基本上以程序“是否具备让程序长时间执行的特征”为标准进行选定的，这里的特征指的就是指令的复用，例如以下几种情况可以放置Safepoint：</p>
<ul>
<li>方法临返回前/调用方法的call指令后</li>
<li>非counted loop的循环跳转之前</li>
<li>异常跳转</li>
</ul>
<p>   总的来说，Safepoint的选定既不能太少以至于让GC等待的时间过长，也不能太频繁以至于过分占用GC空间。</p>
<h5 id="-线程的中断">- 线程的中断</h5>
<p>   对于Safepoint，另一个需要考虑的问题是如何在GC发生时让所有的线程都执行到安全点再停顿下来（不包括执行JNI调试到线程）。有两种中断方式，一种是抢先式中断，一种是主动式中断。</p>
<ul>
<li>抢先式中断：不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让线程执行到安全点上。现在几乎没有虚拟机采用抢先式中断来响应GC事件</li>
<li>主动式中断：当GC需要中断线程的时候，不直接对线程进行操作，仅仅是设置一个标志，各个线程执行时会主动去轮询这个标志，发现中断标志为true时就自己中断挂起，轮询标志的地方和安全点是重合的。</li>
</ul>
<h4 id="3安全区域">3）安全区域</h4>
<p>   Safepoint机制保证了程序在执行时，在一段时间内就会遇到可进入GC的Safepoint。但是如果程序长时间不执行，比如线程进入到Sleep状态或者Blocked状态，线程无法响应JVM的中断请求，因此程序也无法到达安全点。此时需要引入<strong>安全区域（Safe Region）</strong>。</p>
<h5 id="-什么是安全区域">- 什么是安全区域</h5>
<p>   <strong>安全区域是指一段代码片中，引用关系不会发生变化，在这个区域任何地方开始GC都是安全的</strong>，Safe Region可以看做是Safepoint的一个扩展。</p>
<h5 id="-安全区域的实现方式">- 安全区域的实现方式</h5>
<p>   当线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，此时JVM发起了GC时就不需要管标识自己为Safe Region状态的线程了，当线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<h4 id="4进入safepoint时线程如何被挂起">4）进入Safepoint时线程如何被挂起</h4>
<p>   现如今主流虚拟机都是采用主动式中断来响应GC事件，如果触发GC动作，VM thread会在VMThread::loop()方法中调用SafepointSynchronize::begin()方法，最终使所有的线程都进入到safepoint。<br>
   首先看一下OpenJDK里面关于safepoint的一些说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// Begin the process of bringing the system to a safepoint.  </span><br><span class="line">// Java threads can be in several different states and are  </span><br><span class="line">// stopped by different mechanisms:  </span><br><span class="line">//  1. Running interpreted  </span><br><span class="line">//     The interpeter dispatch table is changed to force it to  </span><br><span class="line">//     check for a safepoint condition between bytecodes.  </span><br><span class="line">//  2. Running in native code  </span><br><span class="line">//     When returning from the native code, a Java thread must check  </span><br><span class="line">//     the safepoint _state to see if we must block.  If the  </span><br><span class="line">//     VM thread sees a Java thread in native, it does  </span><br><span class="line">//     not wait for this thread to block.  The order of the memory  </span><br><span class="line">//     writes and reads of both the safepoint state and the Java  </span><br><span class="line">//     threads state is critical.  In order to guarantee that the  </span><br><span class="line">//     memory writes are serialized with respect to each other,  </span><br><span class="line">//     the VM thread issues a memory barrier instruction  </span><br><span class="line">//     (on MP systems).  In order to avoid the overhead of issuing  </span><br><span class="line">//     a mem barrier for each Java thread making native calls, each Java  </span><br><span class="line">//     thread performs a write to a single memory page after changing  </span><br><span class="line">//     the thread state.  The VM thread performs a sequence of  </span><br><span class="line">//     mprotect OS calls which forces all previous writes from all  </span><br><span class="line">//     Java threads to be serialized.  This is done in the  </span><br><span class="line">//     os::serialize_thread_states() call.  This has proven to be  </span><br><span class="line">//     much more efficient than executing a membar instruction  </span><br><span class="line">//     on every call to native code.  </span><br><span class="line">//  3. Running compiled Code  </span><br><span class="line">//     Compiled code reads a global (Safepoint Polling) page that  </span><br><span class="line">//     is set to fault if we are trying to get to a safepoint.  </span><br><span class="line">//  4. Blocked  </span><br><span class="line">//     A thread which is blocked will not be allowed to return from the  </span><br><span class="line">//     block condition until the safepoint operation is complete.  </span><br><span class="line">//  5. In VM or Transitioning between states  </span><br><span class="line">//     If a Java thread is currently running in the VM or transitioning  </span><br><span class="line">//     between states, the safepointing code will wait for the thread to  </span><br><span class="line">//     block itself when it attempts transitions to a new state.</span><br></pre></td></tr></table></figure>
<p>   可以看到在系统进入Safepoint的过程时，Java线程可以处于几种不同的状态，并且可以通过不同的机制停止：</p>
<ul>
<li>当线程在解释模式下运行：解释器调度表会强制检查字节码之间的安全点的状态条件。</li>
<li>当Java线程正在执行native code：如果VM thread发现Java thread正在执行native code，它不会等待Java thread进入阻塞状态。当该Java thread从native code返回时，Java thread必须检查Safepoint状态，以确认是否需要进行阻塞。这里涉及到两个状态，safepoint state 和Java threads state，两个状态的内存写入和读取严格按照顺序执行。为了确保内存写入相对于彼此是序列化的，VM thread进行两种操作，一种是通过内存屏障（Memory barrier）来实现，一种是通过执行一系列mprotect os call，保证之前所有线程状态的按顺序执行，通过调用os :: serialize_thread_states()完成。Hotspot采用后者，因为前者使用内存屏障来实现，需要强势刷新CPU缓存，性能开销较大，后者已被证明比前者效率更高。</li>
<li>运行compiled code：如果想要执行到安全点，虚拟机会把内存页设置为不可读，当线程执行到轮询指令的时候，就会产生一个自陷异常信号，在预先注册的异常处理器中暂停线程实现等待。</li>
<li>当线程处于Block状态时：在Safepoint操作完成之前，不允许被阻塞的线程从阻塞状态返回，即上述提到的Safe Region方式。</li>
<li>当线程处在状态转化的时候：就会去检查Safepoint，如果需要阻塞，就等待线程阻塞自身。</li>
</ul>
<p>   最终实现方式GC线程可以使用mprotect system call来保护那些可以被其他线程写入的内存位置，使得这些内存地址不可写入。当线程访问到被保护的内存地址时，会触发一个SIGSEGV信号，进而触发JVM的signal handler来阻塞这个线程。</p>
<h3 id="4垃圾收集器">4.垃圾收集器</h3>
<p>   如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。接下来讨论的收集器是基于JDK1.7 Update 14 之后的HotSpot虚拟机，如下图所示。<br>
<img src="./jvm-peruse-3_p1.png" width="50%" height="50%">   上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。<br>
   在讨论垃圾收集器的时候会接触到几个名词：并发和并行。它们都是并发编程中的概念，结合垃圾收集器上下文语境，可以理解为：</p>
<ul>
<li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</li>
</ul>
<h4 id="1serial收集器">1）Serial收集器</h4>
<p>   Serial收集器是<strong>最基本、发展历史最悠久的</strong>收集器，采用复制算法的单线程收集器，在JDK1.3.1之前是虚拟机新生代收集的唯一选择。“单线程”的意义并不仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它进行垃圾收集时，必须暂停其他工作线程，直到它收集结束。下图是Serial / Serial Old收集器的运行过程。<br>
<img src="./jvm-peruse-3_p2.png" alt="Serial_Serial Old 收集器">   为了消除或者减少工作线程因内存回收而导致停顿，HotSpot虚拟机开发团队从JKD1.3开始，研发出了越来越优秀（也越来越复杂）的收集器，但这并不意味着Serial收集器被弃用，它依然是虚拟机运行在Client模式下的默认新生代收集器，它有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<h4 id="2parnew收集器">2）ParNew收集器</h4>
<p>   ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略都与Serial收集器完全一样，在实现上，这两种收集器也公用了相当多的代码。ParNew收集器的工作过程如下图所示。<br>
<img src="./jvm-peruse-3_p3.png" alt="ParNew_Serial Old收集器">   ParNew收集器除了多线程收集之外，其他的与Serial收集器并没有太多的创新之处，但它确是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中一个与性能但是很重要的原因是，除了Serial收集器外，目前只有它与CMS收集器配合工作。<br>
   PerNew收集器在单CPU的环境中绝对不会比Serial收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。不过随着可以使用的CPU的数量增加，它对于GC时系统资源的有效利用还是有好处的。</p>
<h4 id="3parallel-scavenge收集器">3）Parallel Scavenge收集器</h4>
<p>   Parallel Scavenge收集器是一个使用复制算法的新生代多线程收集器，与CMS这些关注点是尽可能地缩短垃圾收集时用户线程的停顿时间的等收集器不同，Parallel Scavenge收集器的目的是达到一个<strong>可控制的吞吐量（Throughput）</strong>，吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）。<br>
   停顿时间越短越适合与用户交互的程序，良好的响应速度能提成用户的体验，而高吞吐量则可以<strong>高效地利用CPU时间</strong>，尽快完成程序任务，主要适合在后台运算而不需要太多交互的任务。<br>
   由于与吞吐量有关，Parallel Scavenge收集器也经常称为“吞吐量优先”收集器。Parallel Scavenge收集器还有一个参数是-XX:+UseAdaptiveSizePolicy，当这个参数打开后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为GC自适应的调节策略（GC Ergonomics）。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p>
<h4 id="4serial-old收集器">4）Serial Old收集器</h4>
<p>   Serial Old是Serial收集器的老年代版本，与Serial收集器一样也是一个单线程收集器，使用“标记—整理”算法。这个收集器的主要意义在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种是在JDK1.5以及之前的版本与Parallel Scavenge收集器搭配使用，另一种是作为CMS收集器的后背预案，在并发收集发生Concurrent Mode Failure时使用。下图是Serial / Serial Old收集器运行示意图。<br>
<img src="./jvm-peruse-3_p2.png" alt="Serial_Serial Old 收集器"></p>
<h4 id="5parallel-old收集器">5）Parallel Old收集器</h4>
<p>   Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记—整理”算法。在JKD1.6之后与Parallel Scavenge收集器组成“吞吐量优先”应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。在JDK1.6之前，老年代除了Serial Old以外别无选择。Parallel Scavenge/Parallel Old收集器运行示意图如下图所示。<br>
<img src="./jvm-peruse-3_p4.png" alt="Parallel Old收集器示意图"></p>
<h4 id="6cms收集器concurrent-mrak-sweep">6）CMS收集器（Concurrent Mrak Sweep）</h4>
<p>   <strong>CMS收集器是一种以获取最短回收停顿时间为目标的收集器</strong>。基于“标记—清除”算法实现的，它运作过程相比前面几种收集器来说更复杂一些，整个过程分为4个步骤：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>   其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段长一些，但远比并发标记的时间短。<br>
   由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说CMS收集器的内存回收过程是与用户线程一起并发执行的。下图是CMS收集器的运作步骤中并发和需要停顿的时间。<br>
<img src="./jvm-peruse-3_p5.png" alt="CMS收集器">   CMS是一款优秀的收集器，它的主要优点就是并发收集、低停顿。但它还远达不到完美的程度，它有以下3个明显的缺点：</p>
<ul>
<li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分CPU资源而导致应用程序变慢，总吞吐量变低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是在CPU数量是4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU数量不足4个的时，CMS对用户线程的影响就可能变得很大。</li>
<li>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行会有新的垃圾不断产生，这部分垃圾出现在标记过程之后，CMS无法在当次收集中处理它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。由于在垃圾收集阶段用户线程还需要运行，还需要预留足够的内存空间给用户线程使用，因此CMS收集器不像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集的程序运作使用。</li>
<li>CMS是基于“标记—清除”算法实现的收集器，收集结束会有大量的空间碎片产生，空间碎片过多时，会给大对象分配带来很多麻烦，往往出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</li>
</ul>
<h4 id="7g1收集器">7）G1收集器</h4>
<p>   G1（Garbage-Frist）收集器是当今收集器技术发展的最前沿成果之一，是一款<strong>面向服务器端应用的垃圾收集器</strong>，它被赋予替换CMS收集器的使命。与其他收集器相比，G1具备如下特点。</p>
<ul>
<li>并发与并行：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU核心来缩短Stop-The-World停顿时间，部分收集器原本需要停顿Java线程执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li>
<li>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活一段时间、熬过多次GC的旧对象以获得更好的收集效果。</li>
<li>空间整合：G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能够提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续的内存空间而提前触发下一次GC。</li>
<li>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ul>
<h5 id="-使用g1收集器时java堆的内存布局">- 使用G1收集器时Java堆的内存布局</h5>
<p>   在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，但是G1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离了</strong>，它们都是一部分<strong>Region（不需要连续）的集合</strong>。</p>
<h5 id="-如何建立可预测的停顿时间模型">- 如何建立可预测的停顿时间模型</h5>
<p>   G1收集器之所以能够建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（价值大小由回收所获得的空间大小以及回收所需时间来决定），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First）名称的由来。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<h5 id="-remembered-set">- Remembered Set</h5>
<p>   G1把内存“化整为零”的思路看起来似乎很容易，但现实中Region并不是孤立存在的。换言之，一个对象分配在某个Region中，并非只能被本Region中的其他对象引用，而是可以与整个Java堆的任意对象建立引用关系。那么在做可达性分析的时候，判定对象是否存活就需要扫描整个Java堆才能保持准确性？这显然是不可取的。<br>
   在G1收集器中Region之间的对象引用以及其他收集器中新生代和老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全盘扫描。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全局扫描也不回又遗漏。</p>
<h5 id="-g1收集器的运作方式">- G1收集器的运作方式</h5>
<p>   如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li>
<li>并发标记（Concurrent Marking）：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时很长，但可与用户程序并发执行。</li>
<li>最终标记（Final Marking）：需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收（Live Data Counting and Evacuation）：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。其实这个阶段也可以做到与用户线程一起并发执行，但是因为只回收了一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。下图可以看到G1收集器的运作步骤中并发和需要停顿的阶段。</li>
</ul>
<p><img src="./jvm-peruse-3_p6.png" alt="G1收集器运行示意图"></p>
<h3 id="5内存分配与回收策略">5.内存分配与回收策略</h3>
<p>   对象内存分配在大方向上来说就是在堆上分配（但也有可能经过JIT编译后被拆分成标量类型并间接地在栈上分配）。对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配规则并不是百分百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。</p>
<h4 id="1对象的分配">1）对象的分配</h4>
<p>   大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将触发一次Minor GC。而对于那些需要大量连续内存空间的大对象来说，它对虚拟机的内存分配就是一个坏消息，经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集以获取足够的连续空间来“安置”它们。<br>
   虚拟机提供了一个-XX:PretenureSizeThreshold参数（只对Serial和ParNew两款收集器有效），令大于这个设置值的对象直接在老年代分配。这样做的目的是<strong>避免Eden区及两个Survivor区之间发生大量的内存复制</strong>。</p>
<h4 id="2对象年龄判定和老年代晋升">2）对象年龄判定和老年代晋升</h4>
<p>   虚拟机为了识别哪些对象应该放在新生代，哪些对象应放在老年代，给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经历过一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每经历过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就会被晋升到老年代中。对象晋升老年代的年龄阀值可以通过-XX:MaxTenuringThreshold设置。<br>
   为了能更好地适应不同程序的内存情况，虚拟机并不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中有相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h4 id="3空间分配担保">3）空间分配担保</h4>
<p>   在发生Minor GC之前，如果老年代最大可用的连续空间小于新生代所有对象总空间，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的。如果小于或者HandlePromotionFailure设置不允许冒险，那这时要改为进行一次Full GC。<br>
   所谓风险是因为，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此空间分配担保就是当出现大量对象在Minor GC后仍然存活的情况，就需要老年代来进行分配担保，把Survivor无法容纳的对象直接进入老年代。但是有多少对象会存活下来在实际未完成内存回收之前是无法明确知道的，所以只好取上一次回收晋升到老年代对象容量的平均做来作为一个依据，再与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/jvm-peruse-4/" data-toggle="tooltip" data-placement="top" title="深入理解JVM—虚拟机类加载机制">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/jvm-peruse-2/" data-toggle="tooltip" data-placement="top" title="深入理解JVM—HotSpot虚拟机中对象的分配、布局和访问">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1对象存活判定"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1.&#x5BF9;&#x8C61;&#x5B58;&#x6D3B;&#x5224;&#x5B9A;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1引用计数算法"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">1&#xFF09;&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x7B97;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2可达性分析算法reachability-analysis"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">2&#xFF09;&#x53EF;&#x8FBE;&#x6027;&#x5206;&#x6790;&#x7B97;&#x6CD5;&#xFF08;Reachability Analysis&#xFF09;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3引用的定义"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">3&#xFF09;&#x5F15;&#x7528;&#x7684;&#x5B9A;&#x4E49;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4对象的回收判定"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">4&#xFF09;&#x5BF9;&#x8C61;&#x7684;&#x56DE;&#x6536;&#x5224;&#x5B9A;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5方法区hotspot虚拟机中的永久代的gc"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">5&#xFF09;&#x65B9;&#x6CD5;&#x533A;&#xFF08;HotSpot&#x865A;&#x62DF;&#x673A;&#x4E2D;&#x7684;&#x6C38;&#x4E45;&#x4EE3;&#xFF09;&#x7684;GC</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-回收废弃常量"><span class="toc-nav-number">1.5.1.</span> <span class="toc-nav-text">-&#xA0;&#x56DE;&#x6536;&#x5E9F;&#x5F03;&#x5E38;&#x91CF;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-回收无用的类"><span class="toc-nav-number">1.5.2.</span> <span class="toc-nav-text">-&#xA0;&#x56DE;&#x6536;&#x65E0;&#x7528;&#x7684;&#x7C7B;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2垃圾收集算法"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2.&#x5783;&#x573E;&#x6536;&#x96C6;&#x7B97;&#x6CD5;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1标记-清除算法mark-sweep"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">1&#xFF09;&#x6807;&#x8BB0;-&#x6E05;&#x9664;&#x7B97;&#x6CD5;(Mark-Sweep)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-基本思路"><span class="toc-nav-number">2.1.1.</span> <span class="toc-nav-text">-&#xA0;&#x57FA;&#x672C;&#x601D;&#x8DEF;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-缺点"><span class="toc-nav-number">2.1.2.</span> <span class="toc-nav-text">-&#xA0;&#x7F3A;&#x70B9;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2复制算法copying"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">2&#xFF09;&#x590D;&#x5236;&#x7B97;&#x6CD5;(Copying)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-基本思路"><span class="toc-nav-number">2.2.1.</span> <span class="toc-nav-text">-&#xA0;&#x57FA;&#x672C;&#x601D;&#x8DEF;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-优点"><span class="toc-nav-number">2.2.2.</span> <span class="toc-nav-text">-&#xA0;&#x4F18;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-缺点"><span class="toc-nav-number">2.2.3.</span> <span class="toc-nav-text">-&#xA0;&#x7F3A;&#x70B9;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3标记-整理算法mark-compact"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">3&#xFF09;&#x6807;&#x8BB0;-&#x6574;&#x7406;&#x7B97;&#x6CD5;(Mark-Compact)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-基本思路"><span class="toc-nav-number">2.3.1.</span> <span class="toc-nav-text">-&#xA0;&#x57FA;&#x672C;&#x601D;&#x8DEF;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-优点"><span class="toc-nav-number">2.3.2.</span> <span class="toc-nav-text">-&#xA0;&#x4F18;&#x70B9;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4分代收集算法generational-collection"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">4&#xFF09;&#x5206;&#x4EE3;&#x6536;&#x96C6;&#x7B97;&#x6CD5;(Generational Collection)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-新生代的垃圾收集算法"><span class="toc-nav-number">2.4.1.</span> <span class="toc-nav-text">-&#xA0;&#x65B0;&#x751F;&#x4EE3;&#x7684;&#x5783;&#x573E;&#x6536;&#x96C6;&#x7B97;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-老年代的垃圾收集算法"><span class="toc-nav-number">2.4.2.</span> <span class="toc-nav-text">-&#xA0;&#x8001;&#x5E74;&#x4EE3;&#x7684;&#x5783;&#x573E;&#x6536;&#x96C6;&#x7B97;&#x6CD5;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3hotspot的算法实现"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3.HotSpot&#x7684;&#x7B97;&#x6CD5;&#x5B9E;&#x73B0;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1枚举根节点"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">1&#xFF09;&#x679A;&#x4E3E;&#x6839;&#x8282;&#x70B9;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-什么是gc停顿"><span class="toc-nav-number">3.1.1.</span> <span class="toc-nav-text">-&#xA0;&#x4EC0;&#x4E48;&#x662F;GC&#x505C;&#x987F;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-gc如何快速枚举根节点"><span class="toc-nav-number">3.1.2.</span> <span class="toc-nav-text">-&#xA0;GC&#x5982;&#x4F55;&#x5FEB;&#x901F;&#x679A;&#x4E3E;&#x6839;&#x8282;&#x70B9;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2安全点"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">2&#xFF09;&#x5B89;&#x5168;&#x70B9;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-什么是安全点"><span class="toc-nav-number">3.2.1.</span> <span class="toc-nav-text">-&#xA0;&#x4EC0;&#x4E48;&#x662F;&#x5B89;&#x5168;&#x70B9;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-安全点的位置选定"><span class="toc-nav-number">3.2.2.</span> <span class="toc-nav-text">-&#xA0;&#x5B89;&#x5168;&#x70B9;&#x7684;&#x4F4D;&#x7F6E;&#x9009;&#x5B9A;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-线程的中断"><span class="toc-nav-number">3.2.3.</span> <span class="toc-nav-text">-&#xA0;&#x7EBF;&#x7A0B;&#x7684;&#x4E2D;&#x65AD;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3安全区域"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">3&#xFF09;&#x5B89;&#x5168;&#x533A;&#x57DF;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-什么是安全区域"><span class="toc-nav-number">3.3.1.</span> <span class="toc-nav-text">-&#xA0;&#x4EC0;&#x4E48;&#x662F;&#x5B89;&#x5168;&#x533A;&#x57DF;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-安全区域的实现方式"><span class="toc-nav-number">3.3.2.</span> <span class="toc-nav-text">-&#xA0;&#x5B89;&#x5168;&#x533A;&#x57DF;&#x7684;&#x5B9E;&#x73B0;&#x65B9;&#x5F0F;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4进入safepoint时线程如何被挂起"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">4&#xFF09;&#x8FDB;&#x5165;Safepoint&#x65F6;&#x7EBF;&#x7A0B;&#x5982;&#x4F55;&#x88AB;&#x6302;&#x8D77;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4垃圾收集器"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4.&#x5783;&#x573E;&#x6536;&#x96C6;&#x5668;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1serial收集器"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">1&#xFF09;Serial&#x6536;&#x96C6;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2parnew收集器"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">2&#xFF09;ParNew&#x6536;&#x96C6;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3parallel-scavenge收集器"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">3&#xFF09;Parallel Scavenge&#x6536;&#x96C6;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4serial-old收集器"><span class="toc-nav-number">4.4.</span> <span class="toc-nav-text">4&#xFF09;Serial Old&#x6536;&#x96C6;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5parallel-old收集器"><span class="toc-nav-number">4.5.</span> <span class="toc-nav-text">5&#xFF09;Parallel Old&#x6536;&#x96C6;&#x5668;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6cms收集器concurrent-mrak-sweep"><span class="toc-nav-number">4.6.</span> <span class="toc-nav-text">6&#xFF09;CMS&#x6536;&#x96C6;&#x5668;&#xFF08;Concurrent Mrak Sweep&#xFF09;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#7g1收集器"><span class="toc-nav-number">4.7.</span> <span class="toc-nav-text">7&#xFF09;G1&#x6536;&#x96C6;&#x5668;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-使用g1收集器时java堆的内存布局"><span class="toc-nav-number">4.7.1.</span> <span class="toc-nav-text">-&#xA0;&#x4F7F;&#x7528;G1&#x6536;&#x96C6;&#x5668;&#x65F6;Java&#x5806;&#x7684;&#x5185;&#x5B58;&#x5E03;&#x5C40;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-如何建立可预测的停顿时间模型"><span class="toc-nav-number">4.7.2.</span> <span class="toc-nav-text">-&#xA0;&#x5982;&#x4F55;&#x5EFA;&#x7ACB;&#x53EF;&#x9884;&#x6D4B;&#x7684;&#x505C;&#x987F;&#x65F6;&#x95F4;&#x6A21;&#x578B;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-remembered-set"><span class="toc-nav-number">4.7.3.</span> <span class="toc-nav-text">-&#xA0;Remembered Set</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#-g1收集器的运作方式"><span class="toc-nav-number">4.7.4.</span> <span class="toc-nav-text">-&#xA0;G1&#x6536;&#x96C6;&#x5668;&#x7684;&#x8FD0;&#x4F5C;&#x65B9;&#x5F0F;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5内存分配与回收策略"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">5.&#x5185;&#x5B58;&#x5206;&#x914D;&#x4E0E;&#x56DE;&#x6536;&#x7B56;&#x7565;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1对象的分配"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">1&#xFF09;&#x5BF9;&#x8C61;&#x7684;&#x5206;&#x914D;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2对象年龄判定和老年代晋升"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">2&#xFF09;&#x5BF9;&#x8C61;&#x5E74;&#x9F84;&#x5224;&#x5B9A;&#x548C;&#x8001;&#x5E74;&#x4EE3;&#x664B;&#x5347;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3空间分配担保"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text">3&#xFF09;&#x7A7A;&#x95F4;&#x5206;&#x914D;&#x62C5;&#x4FDD;</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Jvm" title="Jvm">Jvm</a>
                        
                          <a class="tag" href="/tags/#Java" title="Java">Java</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/Williamic">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Williamic 2021 
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://williamic.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
</body>

</html>
